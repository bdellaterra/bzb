#!/bin/bash
set -e

# Stay in browser after editing files
PERSIST=1

# Start with only top-level files/directories displayed
SHALLOW=1

# Don't show hidden files by default
export HIDDEN=''

# Don't show ignored files by default
export NO_IGNORE=''

# Prefer fd over find so ignored files are not listed
if command -v fd &>/dev/null; then
  RECURSIVE_FIND='fd ${HIDDEN:+--hidden} ${NO_IGNORE:+--no-ignore}'
  SHALLOW_FIND='fd --max-depth 1 ${HIDDEN:+--hidden} ${NO_IGNORE:+--no-ignore} --exec echo {/}'
else
  RECURSIVE_FIND='find . ${HIDDEN:+! -name "."} | sed "s:^\./::"'
  SHALLOW_FIND='find . -maxdepth 1 ${HIDDEN:+! -name "."} -execdir basename "{}" \;'
fi

declare -A KEYMAP
declareKeymap() {
  KEYS[${#KEYS[@]}]="$1" && KEYMAP["$1"]="$2"
}

declareKeymap 'right'      "enter directory or edit file"
declareKeymap 'left'       "go to parent directory (not moving past base directory)"
declareKeymap 'ctrl-r'     "move/rename targets to directory named at prompt"
declareKeymap 'alt-r'      "rename targets in current directory"
declareKeymap 'ctrl-x'     "move targets to directory named at prompt"
declareKeymap 'alt-x'      "delete targets"
declareKeymap 'ctrl-s'     "copy/rename targets to directory named at prompt"
declareKeymap 'alt-s'      "copy targets to directory named at prompt"
declareKeymap 'ctrl-d'     "enter directory named at prompt, creating it if necessary"
declareKeymap 'alt-d'      "create directory without entering"
declareKeymap 'ctrl-f'     "edit file named at prompt, creating it if necessary"
declareKeymap 'alt-f'      "create file without editing"
declareKeymap 'alt-b'      "bookmark target directories"
declareKeymap 'alt-u'      "un-bookmark target directories"
declareKeymap 'alt-enter'  "bookmark current directory"
declareKeymap 'alt-bspace' "un-bookmark current directory"
declareKeymap 'alt-right'  "go to next bookmarked directory"
declareKeymap 'alt-left'   "go to previous bookmarked directory"
declareKeymap 'alt-up'     "select and enter bookmarked directory"
declareKeymap 'alt-down'   "select and enter bookmarked directory under current directory"
declareKeymap 'ctrl-/'     "set new base directory at prompt, then go to it"
declareKeymap 'alt-/'      "go to base directory"
declareKeymap 'ctrl-q'     "set alternate directory"
declareKeymap 'alt-q'      "cd to alternate directory"
declareKeymap 'alt-a'      "toggle all nested vs. only top-level files"
declareKeymap 'alt-h'      "toggle display of hidden files"
declareKeymap 'alt-g'      "toggle display of ignored files (requires 'fd' command)"

# comma-separated list for fzf
FZF_KEYS="$(printf ",%s" "${!KEYMAP[@]}" | cut -c2-)"

KEY_USAGE=$(cat <<KEYMAPS
escape:exit file browser
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${!KEYS[@]}"; do echo "${KEYS[$k]}:${KEYMAP[${KEYS[$k]}]}"; done)
KEYMAPS
)

usage() {
cat <<USAGE
usage: $(basename "$0") [options] [target file or directory]

Browse files using fzf. If no target specified start in current directory.

Keymaps are as follows:
$(echo "$KEY_USAGE" | column -t -s ':')

options:
--help                                Show this help text
--recursive,-r                        Show nested files/direcories at start
--hidden,-H                           Show hidden files/direcories at start
--no-ignore,-I                        Show ignored files/direcories at start
--single-run,-s                       Exit browser after editing a file
--shallow-find=COMMAND,-sf=COMMAND    Command to list only top-level files/directories
                                      default: $SHALLOW_FIND
--recursive-find=COMMAND,-rf=COMMAND  Command to list nested files/directories
                                      default: $RECURSIVE_FIND
--base-directory=DIR,-bd=DIR          Specify a base directory instead of deriving it from target
--alternate-directory=DIR,-ad=DIR     Initialize alternate directory at start

Any additional options will be passed to fzf.
USAGE
}

for arg in "$@"; do
  case $arg in
    -h|--help) usage; exit 0 ;;
    -r|--recursive) unset SHALLOW; shift ;;
    -H|--hidden) export HIDDEN=1; shift ;;
    -I|--no-ignore) export NO_IGNORE=1; shift ;;
    -s|--single-run) unset PERSIST; shift ;;
    -sf=*|--shallow-find=*) SHALLOW_FIND="${arg#*=}"; shift ;;
    -rf=*|--recursive-find=*) RECURSIVE_FIND="${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) BASE_DIR="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) ALT_DIR="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    -*) OPTS+=("${arg%%=*}=\"${arg#*=}\""); shift ;;
  esac
done

RecursiveFind() {
  bash -c "echo \"$RECURSIVE_FIND\"";
}

ShallowFind() {
  bash -c "echo \"$SHALLOW_FIND\"";
}

# Derive base directory from target argument,
# or use current directory if none given
if [[ -z "$BASE_DIR" ]]; then
  [[ -d "$1" ]] && BASE_DIR="$1" || BASE_DIR="$(dirname "${1:-$PWD/.}")"
fi
pushd "$BASE_DIR" >/dev/null && pushd +1 >/dev/null

main() {
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
  elif [[ $# -ge 1 ]]; then
    EDIT="${EDITOR:vi}"
    for f in "$@"; do
      EDIT="$EDIT \"$f\""
    done
    bash -c "$EDIT"
    [[ ! $PERSIST ]] && exit 0
  fi

  # CYCLE INTO FZF
  [[ $SHALLOW ]] && FIND=$(ShallowFind) || FIND=$(RecursiveFind)
  FZF="fzf --multi --layout='reverse' --expect='$FZF_KEYS' --prompt='${PWD#$BASE_DIR}>' ${OPTS[@]}"
  { read command; readarray -t targets; } < <(bash -c "$FIND | $FZF")

  # Use Escape or ctrl-c to exit
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  case $command in
    # Use alt-a to toggle showing "all" nested files/directories
    # vs. only those at top-level
    alt-a)
      [[ $SHALLOW ]] && unset SHALLOW || SHALLOW=1
      targets=()
    ;;

    # Use alt-h to toggle showing hidden files/directories
    alt-h)
      [[ $HIDDEN ]] && unset HIDDEN || export HIDDEN=1
      targets=()
    ;;

    # Use alt-g to toggle showing ignored files/directories
    alt-g)
      [[ $NO_IGNORE ]] && unset NO_IGNORE || export NO_IGNORE=1
      targets=()
    ;;

    # Use alt-x to move and rename targets
    ctrl-r)
      read -ep 'Move/Rename to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      if [[ -n "$DIR" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Move/Rename File: ' -i "mv $PWD/$t $DIR/$t" MVRENAME
            [[ -n "$MVRENAME" ]] && bash -c "$MVRENAME"
          fi
        done
      fi
      targets=()
    ;;

    # Use alt-r to rename targets in current directory
    alt-r)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          read -ep 'Move/Rename File: ' -i "mv $t ${ALT_DIR:-.}/$t" RENAME
          [[ -n "$RENAME" ]] && bash -c "$RENAME"
        fi
      done
      targets=()
    ;;

    # Use ctrl-x to move targets
    ctrl-x)
      read -ep 'Move to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      [[ -n "$DIR" ]] && mv -i "${targets[@]}" "$DIR"
      targets=()
    ;;

    # Use alt-x to delete targets
    alt-x)
      REMOVE="rm -rI ${targets[@]}"
      bash -c "$REMOVE"
      targets=()
    ;;

    # Use ctrl-s to copy and rename targets
    ctrl-s)
      read -ep 'Copy/Rename to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      if [[ -n "$DIR" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Copy/Rename File: ' -i "cp $PWD/$t $DIR/$t" RENAME
            [[ -n "$COPY" ]] && bash -c "$COPY"
          fi
        done
      fi
      targets=()
    ;;

    # Use alt-s to copy targets
    alt-s)
      read -ep 'Copy to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      [[ -n "$DIR" ]] && cp -ir "${targets[@]}" "$DIR"
      targets=()
    ;;

    # Use ctrl-d to create and enter directory
    # Use alt-d to create a directory without changing current directory
    ctrl-d|alt-d)
      targets=()
      read -p "Create directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = 'ctrl-d' ]] && targets=("$target")
      fi
    ;;

    # Use ctrl-f to create a file and edit it immediately
    # Use alt-f to create a file without editing
    ctrl-f|alt-f)
      targets=()
      read -p "Create file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = 'ctrl-f' ]] && targets=("$target")
      fi
    ;;

    # Use alt-b to bookmark selected targets
    # If no targets selected, bookmark the current directory
    alt-b)
      DIR="$PWD"
      for b in "${targets[@]}"; do
        cd "$DIR/$b"
        [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
      done
      cd "$DIR"
      targets=()
    ;;

    # Use alt-u to un-bookmark select targets
    # If no targets selected, un-bookmark the current directory
    alt-u)
      for b in "${targets[@]}"; do
        readarray -t DIRS < <(dirs -p -l)
        for i in "${!DIRS[@]}"; do
          if [[ $i -ge 1 && "${DIRS[$i]}" = "$PWD/$b" ]]; then
            popd +$i >/dev/null
          fi
        done
      done
      targets=()
    ;;

    # Use alt-enter to bookmark current directory
    alt-enter)
      [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
      targets=()
    ;;

    # Use alt-bspace to un-bookmark current directory
    alt-bspace)
      readarray -t DIRS < <(dirs -p -l)
      for i in "${!DIRS[@]}"; do
        [[ $i -ge 1 && "${DIRS[$i]}" = "$PWD" ]] && popd +$i >/dev/null
      done
      targets=()
    ;;

    # Use alt-right to go to next bookmarked directory
    alt-right)
      cd "$(dirs -l +1)"
      pushd +1 >/dev/null 
      targets=()
    ;;

    # Use alt-left to go to previous bookmarked directory
    alt-left)
      cd "$(dirs -l -0)"
      pushd -0 >/dev/null 
      targets=()
    ;;

    # Use alt-up to select bookmarked directory using fzf
    alt-up)
      readarray -t DIRS < <(dirs -p -l)
      target="$(printf '%s\n' "${DIRS[@]}" | fzf)"
      [[ -n "$targets" ]] && targets=("$target") || targets=()
    ;;

    # Use alt-down to select bookmarked directory under current directory using fzf
    alt-down)
      readarray -t DIRS < <(dirs -p -l | grep "$PWD")
      target="$(printf '%s\n' "${DIRS[@]}" | fzf)"
      [[ -n "$targets" ]] && targets=("$target") || targets=()
    ;;

    # Use ctrl-/ to set base directory
    # Use alt-/ to enter base directory, or go back
    # to previous directory if already in base directory
    ctrl-/|alt-/)
      if [[ "$command" = 'ctrl-/' || ! -d "$BASE_DIR" ]]; then
        read -ep "Set base directory: " -i "$PWD" DIR
        [[ -d "$DIR" ]] && BASE_DIR="$DIR" || echo "Not a directory"
      fi
      if [[ "$command" = 'alt-/' && -d "$DIR" ]]; then
        [[ "$PWD" = "$BASE_DIR" ]] && cd "$OLDPWD" || cd "$BASE_DIR"
      fi
      targets=()
    ;;

    # Use ctrl-\ to set alternate directory
    # Use alt-\ to enter alternate directory, or go back
    # to previous directory if already in alternate directory
    ctrl-q|alt-q)
      if [[ "$command" = 'ctrl-q' || ! -d "$ALT_DIR" ]]; then
        read -ep "Set alternate directory: " -i "$PWD" DIR
        [[ -d "$DIR" ]] && ALT_DIR="$DIR" || echo "Not a directory"
      fi
      if [[ "$command" = 'alt-q' && -d "$DIR" ]]; then
        [[ "$PWD" = "$ALT_DIR" ]] && cd "$OLDPWD" || cd "$ALT_DIR"
      fi
      targets=()
    ;;

    # Use left arrow to move up a directory (not above base directory)
    left)
      [[ "$PWD" != "$BASE_DIR" ]] && targets=("..") || targets=('.')
    ;;

    # Use enter (parsed as empty string) or right arrow for default action
  esac

  main "${targets[@]}"
}

# Default initial target is current directory
main "$BASE_DIR"
