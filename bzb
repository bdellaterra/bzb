#!/bin/bash
set -e

# Directory where data for loading/restoring sessions is saved (optional)
BZB_DIR="$HOME/.bzb"

# Stay in browser after editing files
PERSIST=1

# Start with only top-level files/directories displayed
SHALLOW=1

# No color output
COLOR=''

# Don't show hidden files
HIDDEN=''

# Don't show ignored files
NO_IGNORE=''

# Prefer 'fd' over 'find' so ignored files are not listed
if command -v fd &>/dev/null; then
  RECURSIVE_FIND='fd ${BZB_COLOR:+--color always} ${BZB_HIDDEN:+--hidden} ${BZB_NO_IGNORE:+--no-ignore}'
  SHALLOW_FIND='fd --max-depth 1 ${BZB_COLOR:+--color always} ${BZB_HIDDEN:+--hidden} ${BZB_NO_IGNORE:+--no-ignore} --exec echo {/}'
else
  RECURSIVE_FIND='find . -not -name '.' ${BZB_HIDDEN:+-not -path "*/.*"} | sed "s:^\./::"'
  SHALLOW_FIND='find . -maxdepth 1 -not -name '.' ${BZB_HIDDEN:+-not -path "*/.*"} -execdir basename "{}" \;'
fi

# Sort ascending
NO_SORT=''
REVERSE=''
SORT='LC_ALL=C sort ${BZB_REVERSE:+-r} -fiu'

# Display preview pane
NO_PREVIEW=''
FILE_PREVIEW='cat {}'
DIRECTORY_PREVIEW='ls ${BZB_COLOR:+--color=always} ${BZB_HIDDEN:+-a} -lh {}'
PREVIEW_WINDOW='right:62%:wrap'

# Save/Load sessions manually
AUTOSAVE_SESSION=''
AUTOLOAD_SESSION=''

declare -A KEYMAP
declareKeymap() {
  KEYS[${#KEYS[@]}]="$1" && KEYMAP["$1"]="$2"
}

declareKeymap 'right'      "enter directory or edit file"
declareKeymap 'left'       "go to parent directory (not moving past base directory)"
declareKeymap 'alt-r'      "rename targets in current directory"
declareKeymap 'alt-m'      "move targets to directory named at prompt"
declareKeymap 'ctrl-alt-m' "move/rename targets into directory named at prompt"
declareKeymap 'alt-x'      "delete targets"
declareKeymap 'alt-c'      "copy targets to directory named at prompt"
declareKeymap 'ctrl-alt-c' "copy/rename targets into directory named at prompt"
declareKeymap 'alt-e'      "create/edit file named at prompt"
declareKeymap 'alt-f'      "create file without editing"
declareKeymap 'alt-d'      "create directory named at prompt"
declareKeymap 'ctrl-alt-d' "create/enter directory named at prompt"
declareKeymap 'alt-b'      "bookmark target directories"
declareKeymap 'ctrl-alt-b' "un-bookmark target directories"
declareKeymap 'alt-enter'  "bookmark current directory"
declareKeymap 'alt-bspace' "un-bookmark current directory"
declareKeymap 'alt-right'  "go to next bookmarked directory"
declareKeymap 'alt-left'   "go to previous bookmarked directory"
declareKeymap 'alt-up'     "select and enter bookmarked directory"
declareKeymap 'alt-down'   "select and enter bookmarked directory under current directory"
declareKeymap 'alt-u'      "go up to base directory"
declareKeymap 'ctrl-alt-u' "set new base directory at prompt, then go to it"
declareKeymap 'alt-a'      "toggle between current and alternate directory"
declareKeymap 'alt-z'      "set alternate directory (default for copy/move prompts)"
declareKeymap 'alt-p'      "go to previous directory"
declareKeymap 'alt-n'      "toggle display of nested vs. only top-level files"
declareKeymap 'alt-h'      "toggle display of hidden files"
declareKeymap 'alt-i'      "toggle display of ignored files (if supported by 'find' command)"
declareKeymap 'alt-v'      "toggle display of preview pane"
declareKeymap 'alt-o'      "toggle sort order"
declareKeymap 'ctrl-alt-o' "toggle whether sorting is enabled/disabled (affects performance)"
declareKeymap 'alt-s'      "Save session to file named at prompt"
declareKeymap 'alt-l'      "Load session from file named at prompt"

# comma-separated list for fzf
FZF_KEYS="$(printf ",%s" "${!KEYMAP[@]}" | cut -c2-)"

KEY_USAGE=$(cat <<KEYMAPS
escape:exit file browser
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${!KEYS[@]}"; do echo "${KEYS[$k]}:${KEYMAP[${KEYS[$k]}]}"; done)
KEYMAPS
)

usage() {
cat <<USAGE
usage: $(basename "$0") [options] [target file or directory]

Browse files using fzf. If no target specified start in the current directory.

Key mappings are as follows:
$(echo "$KEY_USAGE" | column -t -s ':')

options:
--help                             Show this help text
--once,-o                          Exit browser after editing a file
--color,-c                         Show colorized output
--recursive,-r                     Show nested files/direcories at start
--hidden,-H                        Show hidden files/direcories at start
--no-ignore,-I                     Show ignored files/direcories at start
--no-preview,-P                    Disable preview pane that shows file/directory contents
--no-sort,-S                       Disable sorting of files/directories
--reverse-sort,-R                  Reverse the normal sort order
--sort=CMD,-so=CMD                 Command to sort files/directories
                                   default: $SORT
--shallow-find=CMD,-sf=CMD         Command to list only top-level files/directories
                                   default: $SHALLOW_FIND
--recursive-find=CMD,-rf=CMD       Command to list nested files/directories
                                   default: $RECURSIVE_FIND
--file-preview=CMD,-fp=CMD         Command to preview currently focused file
                                   default: $FILE_PREVIEW
--directory-preview=CMD,-dp=CMD    Command to preview currently focused directory
                                   default: $DIRECTORY_PREVIEW
--base-directory=DIR,-bd=DIR       Specify a base directory instead of deriving it from target
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start

Any additional options will be passed to fzf.
USAGE
}

for arg in "$@"; do
  case $arg in
    -h|--help) usage; exit 0 ;;
    -o|--once) PERSIST=''; shift ;;
    -c|--color) COLOR=1; shift ;;
    -r|--recursive) SHALLOW=''; shift ;;
    -H|--hidden) HIDDEN=1; shift ;;
    -I|--no-ignore) NO_IGNORE=1; shift ;;
    -P|--no-preview) NO_PREVIEW=1; shift ;;
    -S|--no-sort) NO_PREVIEW=1; shift ;;
    -R|--reverse-sort) REVERSE=1; shift ;;
    -so=*|--sort=*) SORT="${arg#*=}"; shift ;;
    -sf=*|--shallow-find=*) SHALLOW_FIND="${arg#*=}"; shift ;;
    -rf=*|--recursive-find=*) RECURSIVE_FIND="${arg#*=}"; shift ;;
    -fp=*|--file-preview=*) FILE_PREVIEW="${arg#*=}"; shift ;;
    -dp=*|--directory-preview=*) DIRECTORY_PREVIEW="${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) BASE_DIR="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) ALT_DIR="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    # TODO: Capture non '=' style arguments 
    -*) OPTS+=("${arg%%=*}=\"${arg#*=}\""); shift ;;
  esac
done

# Derive base directory from target, or use current directory if none given
if [[ -z "$BASE_DIR" ]]; then
  [[ -d "$1" ]] && BASE_DIR="$1" || BASE_DIR="$(dirname "${1:-$PWD/.}")"
fi
pushd "$BASE_DIR" >/dev/null && pushd +1 >/dev/null

function save_session() {
  mkdir -p "$(dirname $SESSION)" && touch "$SESSION"
  readarray -t BOOKMARKS < <(dirs -p -l)
  if [[ -w "$SESSION" ]]; then
    declare -p PWD >> "$SESSION"
    [[ "$BASE_DIR" ]] && declare -p BASE_DIR >> "$SESSION"
    [[ "$ALT_DIR" ]] && declare -p ALT_DIR >> "$SESSION"
    declare -p BOOKMARKS > "$SESSION"
    declare -p SHALLOW >> "$SESSION"
    declare -p HIDDEN >> "$SESSION"
    declare -p NO_IGNORE >> "$SESSION"
    declare -p NO_SORT >> "$SESSION"
    declare -p REVERSE >> "$SESSION"
    declare -p NO_PREVIEW >> "$SESSION"
  fi
}

function load_session() {
  dirs -c
  pushd "$BASE_DIR" >/dev/null && pushd +1 >/dev/null
  for b in "${BOOKMARKS[@]}"; do
    [[ -d "$b" ]] && pushd "$b" >/dev/null
  done
  cd "$BASE_DIR"
}

if [[ "$AUTOLOAD_SESSION" ]]; then
  SESSION="${BZB_DIR:+$BZB_DIR/sessions$BASE_DIR/session.bzb}"
  if [[ -r "$SESSION" ]]; then
    . -- "$SESSION"
    load_session;
  fi
fi

# Setup conditional preview for files vs directories
PREVIEW="[ -d {} ] && $DIRECTORY_PREVIEW || $FILE_PREVIEW"

main() {
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
  elif [[ $# -ge 1 ]]; then
    EDIT="${EDITOR:vi}"
    for f in "$@"; do
      EDIT="$EDIT '$f'"
    done
    bash -c "$EDIT"
    [[ ! $PERSIST ]] && exit 0
  fi

  # CYCLE INTO FZF
  export BZB_COLOR="$COLOR"
  export BZB_HIDDEN="$HIDDEN"
  export BZB_NO_IGNORE="$NO_IGNORE"
  export BZB_NO_PREVIEW="$NO_PREVIEW"
  export BZB_REVERSE="$REVERSE"
  [[ $SHALLOW ]] && FIND=$(echo "$SHALLOW_FIND") || FIND=$(echo "$RECURSIVE_FIND")
  [[ $NO_SORT ]] && SORT_PIPE='' || SORT_PIPE=$(bash -c "echo \"| $SORT\"")
  [[ $NO_PREVIEW ]] && PREVIEW_OPTS='' || PREVIEW_OPTS="--preview='$(echo "$PREVIEW")' --preview-window='$PREVIEW_WINDOW'"
  FZF="fzf --multi --layout='reverse' --expect='$FZF_KEYS' --prompt='${PWD#$BASE_DIR}>' $PREVIEW_OPTS"
  { read command; readarray -t targets; } < <(bash -c "$FIND $SORT_PIPE | $FZF ${OPTS[@]}")

  # Use Escape or ctrl-c to exit
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  next_targets=()
  case $command in
    # Use alt-n to toggle showing nested vs only top-level files/directories
    alt-n)
      [[ $SHALLOW ]] && SHALLOW='' || SHALLOW=1
    ;;

    # Use alt-h to toggle showing hidden files/directories
    alt-h)
      [[ $HIDDEN ]] && HIDDEN='' || HIDDEN=1
    ;;

    # Use alt-i to toggle showing ignored files/directories
    alt-i)
      [[ $NO_IGNORE ]] && NO_IGNORE='' || NO_IGNORE=1
    ;;

    # Use alt-v to toggle showing preview pane
    alt-v)
      [[ $NO_PREVIEW ]] && NO_PREVIEW='' || NO_PREVIEW=1
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    alt-o)
      [[ $REVERSE ]] && REVERSE='' || REVERSE=1
    ;;

    # Use ctrl-alt-o to enable/disable sorting
    ctrl-alt-o)
      [[ $NO_SORT ]] && NO_SORT='' || NO_SORT=1
    ;;

    # Use alt-r to rename targets in current directory
    alt-r)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          read -ep 'Move/Rename File: ' -i "mv \"$t\" \"$t\"" CMD
          [[ -n "$CMD" ]] && bash -c "$CMD"
        fi
      done
    ;;

    # Use ctrl-alt-m to move and rename targets
    ctrl-alt-m)
      read -ep 'Move/Rename to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      if [[ -n "$DIR" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Move/Rename File: ' -i "mv '$PWD/$t' '${DIR%/}/$t'" CMD
            [[ -n "$CMD" ]] && bash -c "$CMD"
          fi
        done
      fi
    ;;

    # Use alt-m to move targets
    alt-m)
      read -ep 'Move to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      [[ -n "$DIR" ]] && mv -i "${targets[@]}" "$DIR"
    ;;

    # Use alt-x to delete targets
    alt-x)
      rm -rI "${targets[@]}"
    ;;

    # Use alt-c to copy targets
    alt-c)
      read -ep 'Copy to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      [[ -n "$DIR" ]] && cp -ir "${targets[@]}" "$DIR"
    ;;

    # Use ctrl-alt-c to copy and rename targets
    ctrl-alt-c)
      read -ep 'Copy/Rename to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      if [[ -n "$DIR" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Copy/Rename File: ' -i "cp -ir '$PWD/$t' '$DIR/$t'" CMD
            [[ -n "$CMD" ]] && bash -c "$CMD"
          fi
        done
      fi
    ;;

    # Use ctrl-alt-d to create and enter directory
    # Use alt-d to create a directory without changing current directory
    alt-d|ctrl-alt-d)
      read -p "Create directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = 'ctrl-alt-d' ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-e to create a file and edit it immediately
    # Use alt-f to create a file without editing
    alt-e|alt-f)
      read -p "Create file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = 'alt-e' ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to bookmark selected targets
    alt-b)
      DIR="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$DIR/$b" ]]; then
          cd "$DIR/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$DIR"
    ;;

    # Use ctrl-alt-b to un-bookmark select targets
    ctrl-alt-b)
      for b in "${targets[@]}"; do
        readarray -t DIRS < <(dirs -p -l)
        for i in "${!DIRS[@]}"; do
          if [[ $i -ge 1 && -d "${DIRS[$i]}" && "${DIRS[$i]}" = "$PWD/$b" ]]; then
            popd +$i >/dev/null
          fi
        done
      done
    ;;

    # Use alt-enter to bookmark current directory
    alt-enter)
      [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
    ;;

    # Use alt-bspace to un-bookmark current directory
    alt-bspace)
      readarray -t DIRS < <(dirs -p -l)
      for i in "${!DIRS[@]}"; do
        [[ $i -ge 1 && "${DIRS[$i]}" = "$PWD" ]] && popd +$i >/dev/null
      done
    ;;

    # Use alt-right to go to next bookmarked directory
    alt-right)
      cd "$(dirs -l +1)"
      pushd +1 >/dev/null 
    ;;

    # Use alt-left to go to previous bookmarked directory
    alt-left)
      cd "$(dirs -l -0)"
      pushd -0 >/dev/null 
    ;;

    # Use alt-up to select bookmarked directory using fzf
    alt-up)
      readarray -t DIRS < <(dirs -p -l | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${DIRS[@]}" | fzf)")
    ;;

    # Use alt-down to select bookmarked directory under current directory
    alt-down)
      readarray -t DIRS < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${DIRS[@]}" | fzf)")
    ;;

    # Use ctrl-alt-u to set base directory
    # Use alt-u to go to base directory, or go back
    # to previous directory if already in base directory
    alt-u|ctrl-alt-u)
      if [[ "$command" = 'ctrl-alt-u' || ! -d "$BASE_DIR" ]]; then
        read -ep "Set base directory: " -i "$PWD" DIR
        [[ -d "$DIR" ]] && BASE_DIR="${DIR%/}" || echo "Not a directory"
      fi
      if [[ -d "$BASE_DIR" ]]; then
        [[ "$PWD" = "$BASE_DIR" ]] && cd "$OLDPWD" || cd "$BASE_DIR"
      fi
    ;;

    # Use alt-z to set alternate directory
    # Use alt-a to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    alt-a|alt-z)
      if [[ "$command" = 'alt-z' || ! -d "$ALT_DIR" ]]; then
        read -ep "Set alternate directory: " -i "$PWD" DIR
        [[ -d "$DIR" ]] && ALT_DIR="${DIR%/}" || echo "Not a directory"
      fi
      if [[ "$command" = 'alt-a' && -d "$ALT_DIR" ]]; then
        [[ "$PWD" = "$ALT_DIR" ]] && cd "$OLDPWD" || cd "$ALT_DIR"
      fi
    ;;

    # Use alt-s to save session
    alt-s)
      SESSION="${BZB_DIR:+$BZB_DIR/sessions$BASE_DIR/session.bzb}"
      read -ep "Save session: " -i "$SESSION" SESSION
      if [[ -n "$SESSION" ]]; then
        save_session
      fi
    ;;

    # Use alt-l to load session
    alt-l)
      SESSION="${BZB_DIR:+$BZB_DIR/sessions$BASE_DIR/session.bzb}"
      read -ep "Load session: " -i "$SESSION" SESSION
      if [[ -r "$SESSION" ]]; then
        . -- "$SESSION"
        load_session
      fi
    ;;

    # Use left arrow to move up a directory (not above base directory)
    left)
      [[ "$PWD" != "$BASE_DIR" ]] && next_targets=("..") || next_targets=('.')
    ;;

    # Use enter (parsed as empty string) or right arrow for default action
    *)
      next_targets=("${targets[@]}")
    ;;
  esac

  if [[ "$AUTOSAVE_SESSION" ]]; then
    SESSION="${BZB_DIR:+$BZB_DIR/sessions$BASE_DIR/session.bzb}"
    if [[ -n "$SESSION" ]]; then
      save_session
    fi
  fi

  main "${next_targets[@]}"
}

# Default initial target is current directory
main "$BASE_DIR"
