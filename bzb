#!/bin/bash
set -e

# Stay in browser after editing files
PERSIST=1

# Start with only top-level files/directories displayed
SHALLOW=1

# No color output by default
export COLOR=''

# Don't show hidden files by default
export HIDDEN=''

# Don't show ignored files by default
export NO_IGNORE=''

# Sort ascending
NO_SORT=''
REVERSE=''
SORT='LC_ALL=C sort ${REVERSE:+'-r'} -u'

# Prefer 'fd' over 'find' so ignored files are not listed
if command -v fd &>/dev/null; then
  RECURSIVE_FIND='fd ${COLOR:+--color always} ${HIDDEN:+--hidden} ${NO_IGNORE:+--no-ignore}'
  SHALLOW_FIND='fd ${COLOR:+--color always} --max-depth 1 ${HIDDEN:+--hidden} ${NO_IGNORE:+--no-ignore} --exec echo {/}'
else
  RECURSIVE_FIND='find . ${HIDDEN:+! -name "."} | sed "s:^\./::"'
  SHALLOW_FIND='find . -maxdepth 1 ${HIDDEN:+! -name "."} -execdir basename "{}" \;'
fi

# Preview enabled by derfault
NO_PREVIEW=''
FILE_PREVIEW='cat {}'
DIRECTORY_PREVIEW='ls ${COLOR:+--color=always} ${HIDDEN:+-a} -lh {}'
PREVIEW="echo;[ -d {} ] && $DIRECTORY_PREVIEW || $FILE_PREVIEW"
PREVIEW_WINDOW='right:62%:wrap'

declare -A KEYMAP
declareKeymap() {
  KEYS[${#KEYS[@]}]="$1" && KEYMAP["$1"]="$2"
}

declareKeymap 'right'      "enter directory or edit file"
declareKeymap 'left'       "go to parent directory (not moving past base directory)"
declareKeymap 'ctrl-r'     "move/rename targets to directory named at prompt"
declareKeymap 'alt-r'      "rename targets in current directory"
declareKeymap 'ctrl-x'     "move targets to directory named at prompt"
declareKeymap 'alt-x'      "delete targets"
declareKeymap 'ctrl-s'     "copy/rename targets to directory named at prompt"
declareKeymap 'alt-s'      "copy targets to directory named at prompt"
declareKeymap 'ctrl-d'     "create/enter directory named at prompt"
declareKeymap 'alt-d'      "create directory without entering"
declareKeymap 'ctrl-f'     "create/edit file named at prompt"
declareKeymap 'alt-f'      "create file without editing"
declareKeymap 'alt-b'      "bookmark target directories"
declareKeymap 'alt-u'      "un-bookmark target directories"
declareKeymap 'alt-enter'  "bookmark current directory"
declareKeymap 'alt-bspace' "un-bookmark current directory"
declareKeymap 'alt-right'  "go to next bookmarked directory"
declareKeymap 'alt-left'   "go to previous bookmarked directory"
declareKeymap 'alt-up'     "select and enter bookmarked directory"
declareKeymap 'alt-down'   "select and enter bookmarked directory under current directory"
declareKeymap 'ctrl-/'     "set new base directory at prompt, then go to it"
declareKeymap 'alt-/'      "go to base directory"
declareKeymap 'ctrl-q'     "set alternate directory"
declareKeymap 'alt-q'      "go to alternate directory"
declareKeymap 'alt-p'      "go to previous directory"
declareKeymap 'alt-a'      "toggle all nested vs. only top-level files"
declareKeymap 'alt-h'      "toggle display of hidden files"
declareKeymap 'alt-g'      "toggle display of ignored files (if supported by 'find' command)"
declareKeymap 'alt-v'      "toggle display of preview pane"
declareKeymap 'alt-o'      "toggle sort order"
declareKeymap 'ctrl-o'     "toggle whether sorting is enabled/disabled"

# comma-separated list for fzf
FZF_KEYS="$(printf ",%s" "${!KEYMAP[@]}" | cut -c2-)"

KEY_USAGE=$(cat <<KEYMAPS
escape:exit file browser
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${!KEYS[@]}"; do echo "${KEYS[$k]}:${KEYMAP[${KEYS[$k]}]}"; done)
KEYMAPS
)

usage() {
cat <<USAGE
usage: $(basename "$0") [options] [target file or directory]

Browse files using fzf. If no target specified start in the current directory.

Key mappings are as follows:
$(echo "$KEY_USAGE" | column -t -s ':')

options:
--help                             Show this help text
--recursive,-r                     Show nested files/direcories at start
--color,-c                         Show colorized output
--hidden,-H                        Show hidden files/direcories at start
--no-ignore,-I                     Show ignored files/direcories at start
--no-preview,-P                    Disable preview pane showing file/directory contents
--no-sort,-S                       Disable sorting of files/directories
--reverse-sort,-R                  Reverse the normal sort order
--single-run,-s                    Exit browser after editing a file
--base-directory=DIR,-bd=DIR       Specify a base directory instead of deriving it from target
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start
--shallow-find=CMD,-sf=CMD         Command to list only top-level files/directories
                                   default: $SHALLOW_FIND
--recursive-find=CMD,-rf=CMD       Command to list nested files/directories
                                   default: $RECURSIVE_FIND
--file-preview=CMD,-fp=CMD         Command to preview currently focused file
                                   default: $FILE_PREVIEW
--directory-preview=CMD,-dp=CMD    Command to preview currently focused directory
                                   default: $DIRECTORY_PREVIEW

Any additional options will be passed to fzf.
USAGE
}

for arg in "$@"; do
  case $arg in
    -h|--help) usage; exit 0 ;;
    -r|--recursive) unset SHALLOW; shift ;;
    -c|--color) export COLOR=1; shift ;;
    -s|--single-run) unset PERSIST; shift ;;
    -H|--hidden) export HIDDEN=1; shift ;;
    -I|--no-ignore) export NO_IGNORE=1; shift ;;
    -P|--no-preview) export NO_PREVIEW=1; shift ;;
    -S|--no-sort) export NO_PREVIEW=1; shift ;;
    -R|--reverse-sort) REVERSE=1; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) BASE_DIR="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) ALT_DIR="${arg#*=}"; shift ;;
    -sf=*|--shallow-find=*) SHALLOW_FIND="${arg#*=}"; shift ;;
    -rf=*|--recursive-find=*) RECURSIVE_FIND="${arg#*=}"; shift ;;
    -fp=*|--file-preview=*) FILE_PREVIEW="${arg#*=}"; shift ;;
    -dp=*|--directory-preview=*) DIRECTORY_PREVIEW="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    # TODO: Capture non '=' style arguments 
    -*) OPTS+=("${arg%%=*}=\"${arg#*=}\""); shift ;;
  esac
done

echo "$FILE_PREVIEW"
echo "$(Preview)"

# Derive base directory from target, or use current directory if none given
if [[ -z "$BASE_DIR" ]]; then
  [[ -d "$1" ]] && BASE_DIR="$1" || BASE_DIR="$(dirname "${1:-$PWD/.}")"
fi
pushd "$BASE_DIR" >/dev/null && pushd +1 >/dev/null

main() {
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
  elif [[ $# -ge 1 ]]; then
    EDIT="${EDITOR:vi}"
    for f in "$@"; do
      EDIT="$EDIT '$f'"
    done
    bash -c "$EDIT"
    [[ ! $PERSIST ]] && exit 0
  fi

  # CYCLE INTO FZF
  [[ $SHALLOW ]] && FIND=$(echo "$SHALLOW_FIND") || FIND=$(echo "$RECURSIVE_FIND")
  SORT="LC_ALL=C sort ${REVERSE:+'-r'} -u"
  [[ $NO_SORT ]] && SORT_PIPE='' || SORT_PIPE="| $SORT"
  [[ $NO_PREVIEW ]] && PREVIEW_OPTS='' || PREVIEW_OPTS="--preview='$(echo "$PREVIEW")' --preview-window='$PREVIEW_WINDOW'"
  FZF="fzf --multi --layout='reverse' --expect='$FZF_KEYS' --prompt='${PWD#$BASE_DIR}>' $PREVIEW_OPTS"
  { read command; readarray -t targets; } < <(bash -c "$FIND $SORT_PIPE | $FZF ${OPTS[@]}")

  # Use Escape or ctrl-c to exit
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  next_targets=()
  case $command in
    # Use alt-a to toggle showing all nested vs only top-level files/directories
    alt-a)
      [[ $SHALLOW ]] && unset SHALLOW || SHALLOW=1
    ;;

    # Use alt-h to toggle showing hidden files/directories
    alt-h)
      [[ $HIDDEN ]] && unset HIDDEN || export HIDDEN=1
    ;;

    # Use alt-g to toggle showing ignored files/directories
    alt-g)
      [[ $NO_IGNORE ]] && unset NO_IGNORE || export NO_IGNORE=1
    ;;

    # Use alt-v to toggle showing preview pane
    alt-v)
      [[ $NO_PREVIEW ]] && unset NO_PREVIEW || export NO_PREVIEW=1
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    alt-o)
      [[ $REVERSE ]] && unset REVERSE || REVERSE=1
    ;;

    # Use ctrl-o to enable/disable sorting
    ctrl-o)
      [[ $NO_SORT ]] && unset NO_SORT || NO_SORT=1
    ;;

    # Use ctrl-r to move and rename targets
    ctrl-r)
      read -ep 'Move/Rename to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      if [[ -n "$DIR" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Move/Rename File: ' -i "mv '$PWD/$t' '${DIR%/}/$t'" CMD
            [[ -n "$CMD" ]] && bash -c "$CMD"
          fi
        done
      fi
    ;;

    # Use alt-r to rename targets in current directory
    alt-r)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          read -ep 'Move/Rename File: ' -i "mv \"$t\" \"${ALT_DIR:-.}/$t\"" CMD
          [[ -n "$CMD" ]] && bash -c "$CMD"
        fi
      done
    ;;

    # Use ctrl-x to move targets
    ctrl-x)
      read -ep 'Move to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      [[ -n "$DIR" ]] && mv -i "${targets[@]}" "$DIR"
    ;;

    # Use alt-x to delete targets
    alt-x)
      rm -rI "${targets[@]}"
    ;;

    # Use ctrl-s to copy and rename targets
    ctrl-s)
      read -ep 'Copy/Rename to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      if [[ -n "$DIR" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Copy/Rename File: ' -i "cp -ir '$PWD/$t' '$DIR/$t'" CMD
            [[ -n "$CMD" ]] && bash -c "$CMD"
          fi
        done
      fi
    ;;

    # Use alt-s to copy targets
    alt-s)
      read -ep 'Copy to Directory: ' -i "${ALT_DIR:-$BASE_DIR}" DIR
      [[ -n "$DIR" ]] && cp -ir "${targets[@]}" "$DIR"
    ;;

    # Use ctrl-d to create and enter directory
    # Use alt-d to create a directory without changing current directory
    ctrl-d|alt-d)
      read -p "Create directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = 'ctrl-d' ]] && next_targets=("$target")
      fi
    ;;

    # Use ctrl-f to create a file and edit it immediately
    # Use alt-f to create a file without editing
    ctrl-f|alt-f)
      read -p "Create file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = 'ctrl-f' ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to bookmark selected targets
    alt-b)
      DIR="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$DIR/$b" ]]; then
          cd "$DIR/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$DIR"
    ;;

    # Use alt-u to un-bookmark select targets
    alt-u)
      for b in "${targets[@]}"; do
        readarray -t DIRS < <(dirs -p -l)
        for i in "${!DIRS[@]}"; do
          if [[ $i -ge 1 && -d "${DIRS[$i]}" && "${DIRS[$i]}" = "$PWD/$b" ]]; then
            popd +$i >/dev/null
          fi
        done
      done
    ;;

    # Use alt-enter to bookmark current directory
    alt-enter)
      [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
    ;;

    # Use alt-bspace to un-bookmark current directory
    alt-bspace)
      readarray -t DIRS < <(dirs -p -l)
      for i in "${!DIRS[@]}"; do
        [[ $i -ge 1 && "${DIRS[$i]}" = "$PWD" ]] && popd +$i >/dev/null
      done
    ;;

    # Use alt-right to go to next bookmarked directory
    alt-right)
      cd "$(dirs -l +1)"
      pushd +1 >/dev/null 
    ;;

    # Use alt-left to go to previous bookmarked directory
    alt-left)
      cd "$(dirs -l -0)"
      pushd -0 >/dev/null 
    ;;

    # Use alt-up to select bookmarked directory using fzf
    alt-up)
      readarray -t DIRS < <(dirs -p -l | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${DIRS[@]}" | fzf)")
    ;;

    # Use alt-down to select bookmarked directory under current directory
    alt-down)
      readarray -t DIRS < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${DIRS[@]}" | fzf)")
    ;;

    # Use ctrl-/ to set base directory
    # Use alt-/ to go to base directory, or go back
    # to previous directory if already in base directory
    ctrl-/|alt-/)
      if [[ "$command" = 'ctrl-/' || ! -d "$BASE_DIR" ]]; then
        read -ep "Set base directory: " -i "$PWD" DIR
        [[ -d "$DIR" ]] && BASE_DIR="$DIR" || echo "Not a directory"
      fi
      if [[ "$command" = 'alt-/' && -d "$DIR" ]]; then
        [[ "$PWD" = "$BASE_DIR" ]] && cd "$OLDPWD" || cd "$BASE_DIR"
      fi
    ;;

    # Use ctrl-q to set alternate directory
    # Use alt-q to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    ctrl-q|alt-q)
      if [[ "$command" = 'ctrl-q' || ! -d "$ALT_DIR" ]]; then
        read -ep "Set alternate directory: " -i "$PWD" DIR
        [[ -d "$DIR" ]] && ALT_DIR="$DIR" || echo "Not a directory"
      fi
      if [[ "$command" = 'alt-q' && -d "$DIR" ]]; then
        [[ "$PWD" = "$ALT_DIR" ]] && cd "$OLDPWD" || cd "$ALT_DIR"
      fi
    ;;

    # Use alt-p to go to previous directory
    alt-p)
      cd "$OLDPWD"
    ;;

    # Use left arrow to move up a directory (not above base directory)
    left)
      [[ "$PWD" != "$BASE_DIR" ]] && next_targets=("..") || next_targets=('.')
    ;;

    # Use enter (parsed as empty string) or right arrow for default action
    *)
      next_targets=("${targets[@]}")
    ;;
  esac

  main "${next_targets[@]}"
}

# Default initial target is current directory
main "$BASE_DIR"
