#!/bin/bash
set -e

script_name=$(basename "${BASH_SOURCE[0]}")

if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
  echo "Error: $script_name requires a newer version of bash" 1>&2
  exit 1
fi


# FUNCTIONS

# Test if command exists
has() { command -v "$1" &>/dev/null; }

# Test if variable is defined
defined() { [[ -n "$1" && -n "${!1+defined}" ]] || return 1; }

# Set global variable with name matching first argument to value provided as second argument
assign() {
  # Avoid polluting global namespace when setting variable if declare supports -g option (bash version 4.2+)
  if [[ "${BASH_VERSINFO[0]}" -ge 4 && "${BASH_VERSINFO[1]}" -ge 2 ]]; then
    declare -g "$1=$2"
  else
    export "$1=$2"
  fi
}

# In the variable name provided as first argument, store the default value provided
# as second argument. If BZB_ prefixed all-caps variable is defined use its value instead
init() {
  override="BZB_${1^^}"
  defined "$override" && assign "$1" "${!override}" || assign "$1" "$2"
}

# Initialize all variable names provided to true/on,
# allowing override by BZB_ prefixed all-caps variable only if previously unset
enable() {
  for var in "$@"; do
    defined "$var" && assign "$var" 1 || init "$var" 1
  done
}

# Initialize all variable names provided to false/off,
# allowing override by BZB_ prefixed all-caps variable only if previously unset
disable() {
  for var in "$@"; do
    defined "$var" && assign "$var" '' || init "$var" ''
  done
}

# Enable setting if disabled. Disable it if enabled
toggle() { [[ ${!1} ]] && disable "$1" || enable "$1"; }

# Leave alternate screen manually on exit after using fzf '--no-clear' option
clear_fzf() { [[ $fzf_command && $no_clear ]] && tput rmcup; }


# BINDINGS

# Set readline keybinds for cancelling prompts with ctrl-g or double-escape
# Binding single-escape could cause side effects due to its use as a common meta character
bind '"\C-g":"\C-k\C-u
"' '"\e\e":"\C-g"' &>/dev/null

# Set fzf keybinds for movement and exit actions
init fzf_bind '--bind=alt-k:up,alt-j:down,ctrl-g:ignore,esc:cancel'
init fzf_submenu_bind '--bind=alt-k:up,alt-j:down,ctrl-g:unix-line-discard+print-query,esc:unix-line-discard+print-query'

declare -A key_definitions key_actions action_keys
map() {
  keys[${#keys[@]}]="$2"
  key_definitions["$2"]="$3"
  key_actions["$2"]="$1"
  action_keys["$1"]="$2"
}

map 'enter'                   'right'       "enter directory or edit file"
map 'enter2'                  'ctrl-j'      "enter directory or edit file"
map 'back'                    'left'        "go to parent directory (not moving past base directory)"
map 'back2'                   'ctrl-k'      "go to parent directory (not moving past base directory)"
map 'launch'                  'alt-q'       "(q)uick-launch targets using native client"
map 'grep'                    'alt-f'       "grep/(f)ind pattern specified at prompt ('left' will exit grep mode)"
map 'toggle-grep'             'ctrl-g'      "cancel submenu or prompt / toggle (g)rep mode preserving pattern"
map 'move'                    'alt-m'       "(m)ove targets to directory named at prompt"
map 'rename'                  'alt-r'       "(r)ename targets in current directory"
map 'move-rename'             'ctrl-alt-m'  "(m)ove/rename targets into directory named at prompt"
map 'delete'                  'alt-x'       "delete targets"
map 'copy'                    'alt-c'       "(c)opy targets to directory named at prompt"
map 'copy-rename'             'ctrl-alt-c'  "(c)opy/rename targets into directory named at prompt"
map 'create-file'             'alt-t'       "create (a.k.a. \"(t)ouch\") file named at prompt"
map 'create-edit-file'        'ctrl-alt-t'  "create/(e)dit file named at prompt"
map 'create-edit-file2'       'alt-e'       "create/(e)dit file named at prompt"
map 'create-dir'              'alt-d'       "create (d)irectory named at prompt"
map 'create-enter-dir'        'ctrl-alt-d'  "create/enter (d)irectory named at prompt"
map 'toggle-bookmark'         'alt-b'       "toggle (b)ookmark for current directory"
map 'bookmark-targets'        'ctrl-alt-b'  "(b)ookmark targets"
map 'unbookmark'              'ctrl-alt-u'  "(u)nbookmark selected directories"
map 'prev-bookmark'           'alt-left'    "jump bac(k)ward through list of bookmarks"
map 'prev-bookmark2'          'alt-k'       "jump bac(k)ward through list of bookmarks"
map 'next-bookmark'           'alt-right'   "(j)ump forward through list of bookmarks"
map 'next-bookmark2'          'alt-j'       "(j)ump forward through list of bookmarks"
map 'select-bookmark'         'alt-up'      "select and enter bookmarked directory"
map 'select-bookmark2'        'ctrl-alt-k'  "select and enter bookmarked directory"
map 'select-nested-bookmark'  'alt-down'    "select and enter bookmarked directory under current directory"
map 'select-nested-bookmark2' 'ctrl-alt-j'  "select and enter bookmarked directory under current directory"
map 'enter-alt-dir'           'alt-a'       "switch between current and (a)lternate directory"
map 'set-alt-dir'             'ctrl-alt-a'  "set (a)lternate directory (default for copy/move prompts)"
map 'enter-base-dir'          'alt-u'       "switch between current and base directory"
map 'enter-prev-dir'          'alt-p'       "switch between current and (p)revious directory"
map 'prompt-dir'              'alt-g'       "(g)o to directory named at prompt"
map 'set-base-dir'            'ctrl-alt-g'  "set new base directory at prompt and (g)o to it"
map 'toggle-statusline'       'alt-l'       "toggle visibility of the statusline"
map 'toggle-hide'             'alt-h'       "toggle (v)isibility of hidden files"
map 'toggle-ignore'           'alt-i'       "toggle visibility of (i)gnored files (if supported)"
map 'toggle-nested'           'alt-n'       "toggle listing (n)ested vs. only top-level files"
map 'toggle-sort'             'alt-s'       "toggle (s)orting of results (affects performance)"
map 'toggle-nested-sort'      'ctrl-alt-n'  "toggle sorting of nested results (affects performance)"
map 'toggle-sort-order'       'alt-o'       "toggle sort (o)rder ascending/descending"
map 'restore-settings'        'ctrl-alt-r'  "(r)estore initial view/sort settings"
map 'toggle-preview'          'alt-v'       "toggle visibility of pre(v)iew pane"
map 'load-session'            'ctrl-alt-l'  "load session from file named at prompt"
map 'save-session'            'ctrl-alt-s'  "save session to file named at prompt"

# comma-separated list of custom mappings for fzf
readonly fzf_keys="$(printf ",%s" "${keys[@]}" | cut -c2-)"


# USAGE

usage() {
cat <<USAGE
usage: $script_name [options] [target file or directory]

Browse files using fzf. If no target is specified start in the current directory.

Key mappings:

$(awk -F ':' '{ printf("%-12s %-66s %s\n", $1, $2, $3) }' <(
cat <<KEY_USAGE
KEYMAP:DESCRIPTION:ACTION_NAME
escape:exit file browser
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${keys[@]}"; do echo "$k:${key_definitions[$k]}:${key_actions[$k]}"; done)
KEY_USAGE
))

Options:

--help                             Show this help text
--once,-o                          Exit browser after editing a file
--color,-c                         Show colorized output
--nested,-n                        List nested files/directories at start
--no-hide,-H                       Show hidden files/directories at start
--no-ignore,-I                     Show ignored files/directories at start
--reverse,-r                       Reverse the normal sort order
--no-sort,-S                       Disable sorting of files/directories
--no-nested-sort,-NS               Disable sorting of nested files/directories
--no-edit,-E                       Log selections to file instead of launching editor
--no-preview,-P                    Disable preview pane that shows file/directory contents
--no-statusline,-L                 Disable statusline that shows current state of various settings
--autosave-session,-as             Save bookmarks and view/sort settings continuously
--autoload-session,-al             Load bookmarks and view/sort settings on entering base directory
--grep=PATTERN,-g=PATTERN          Start in grep mode, searching files for specified pattern
--base-directory=DIR,-bd=DIR       Specify base directory instead of deriving it from target argument
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start
--data-directory=DIR,-dd=DIR       Specify directory for storing sessions and other data

Most options can be inverted by reversing uppercase/lowercase for the short form or adding/removing
the 'no-' prefix for the long form. Additional options will be passed on to fzf, with the long form using
an equals sign required for options that take values, unless no unescaped spaces are used in the assignment.
(e.g. '--query=STR' or '-qSTR', not '-q STR')
USAGE
}


# OPTIONS

for arg in "$@"; do
  case $arg in
    --help) usage; exit 0 ;;
    -o|--once) enable BZB_ONCE; shift ;;
    -O|--no-once) disable BZB_ONCE; shift ;;
    -c|--color) enable BZB_COLOR; shift ;;
    -C|--no-color) disable BZB_COLOR; shift ;;
    -n|--nested) enable BZB_NESTED; shift ;;
    -N|--no-nested) disable BZB_NESTED; shift ;;
    -h|--hide) enable BZB_HIDE; shift ;;
    -H|--no-hide) disable BZB_HIDE; shift ;;
    -i|--ignore) enable BZB_IGNORE; shift ;;
    -I|--no-ignore) disable BZB_IGNORE; shift ;;
    -s|--sort) enable BZB_SORTED; shift ;;
    -S|--no-sort) disable BZB_SORTED; shift ;;
    -ns|--nested-sort) enable BZB_NESTED_SORT; shift ;;
    -NS|--no-nested-sort) disable BZB_NESTED_SORT; shift ;;
    -r|--reverse) enable BZB_REVERSE; shift ;;
    -R|--no-reverse) disable BZB_REVERSE; shift ;;
    -e|--edit) disable BZB_NO_EDIT; disable BZB_ONCE; shift ;;
    -E|--no-edit) enable BZB_NO_EDIT; enable BZB_ONCE; shift ;;
    -v|--preview) enable BZB_PREVIEW; shift ;;
    -V|--no-preview) disable BZB_PREVIEW; shift ;;
    -l|--statusline) enable BZB_STATUSLINE; shift ;;
    -L|--no-statusline) disable BZB_STATUSLINE; shift ;;
    -as|--autosave-session) enable BZB_AUTOSAVE_SESSION; shift ;;
    -AS|--no-autosave-session) disable BZB_AUTOSAVE_SESSION; shift ;;
    -al|--autoload-session) enable BZB_AUTOLOAD_SESSION; shift ;;
    -AL|--no-autoload-session) disable BZB_AUTOLOAD_SESSION; shift ;;
    -g=*|--grep=*) enable BZB_GREP_MODE; BZB_GREP_QUERY="${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) BZB_BASE_DIR="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) BZB_ALT_DIR="${arg#*=}"; shift ;;
    -dd=*|--data-dir=*|--data-directory=*) BZB_DATA_DIR="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    # TODO: Capture options set with values after whitespace, not just '=' style assignments
    -*) [[ "$arg" == *=* ]] && BZB_FZF_EXTRA_OPTIONS+=" ${arg%%=*}=\"${arg#*=}\"" || BZB_FZF_EXTRA_OPTIONS+=" \"$arg\""; shift ;;
  esac
done


# ARGUMENTS

initial_target="$1"


# SETTINGS

# Detect terminal/color-support and exit if not interactive
if [[ -t 0 || -p /dev/stdin ]]; then
  if has tput; then
    enable no_clear && readonly no_clear
    trap clear_fzf EXIT
    test $(tput colors) -ge 8 && enable color || disable color
  fi
else
  echo "Error: $script_name must be run interactively" 1>&2
  exit 1
fi

# Derive base directory from target, or use current directory if none given
[[ -d "$initial_target" ]] && init base_dir "$initial_target" || init base_dir "$(dirname "${initial_target:-$PWD/.}")"
pushd "$base_dir" >/dev/null && pushd +1 >/dev/null

# Alternate directory for quick naviagtion and file-operations not set by default 
disable alt_dir

# Directory where data for loading/restoring sessions is saved (optional)
init data_dir "$HOME/.bzb" && readonly data_dir

# Default behavior is to launch $EDITOR as the enter-action for files. Enabling the option
# below will instead only log selected targets to a 'selection' file inside 'data_dir'.
# This helps communicate user actions to an external program that has launched bzb as an
# integrated file browser. Enabling this option will also enable the 'once' option
disable no_edit

# Default enabled/disabled settings
enable sorted preview statusline hide ignore
disable once nested reverse grep_mode autosave_session autoload_session

# Additional options to be passed to fzf
disable fzf_extra_options


# COMMANDS

# Find Commands: Prefer 'fd' over 'find' so ignored files are not listed
if has fd; then
  disable no_find_ignore_status
  init find_nested \
    "fd \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
  init find_shallow \
    "fd --max-depth 1 \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
else
  enable no_find_ignore_status
  init find_nested \
    "find . -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
  init find_shallow \
    "find . -maxdepth 1 -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
fi
readonly no_find_ignore_status

# Sort Command:
enable parallel_sort
init sort_shallow \
  "LC_ALL=C sort \${BZB_REVERSE:+-r} -fiu"
if has parallel && test $parallel_sort; then
  enable nested_sort
  init sort_nested \
    "LC_ALL=C parallel --pipe --block 64k sort \${BZB_REVERSE:+-r} -fiu 2>/dev/null"
else
  disable parallel_sort
  disable nested_sort
  init sort_nested "$sort_shallow"
fi
readonly parallel_sort

# Preview Commands:
init preview_directory \
  "ls \${BZB_COLOR:+--color=always} \${BZB_HIDDEN:+-a} -lh {}"
init preview_text \
  "cat {}"
init is_binary \
  'test `head -qc 8192 {} 2>/dev/null | grep -o "[^[:print:]]" 2>/dev/null | wc -c` -gt 16'

if has file; then
  init preview_binary \
    "file -L {}"
  init is_binary \
    '[[ ! "$(file -L {})" =~ 'text' ]] && '"$is_binary"
else
  init preview_binary \
    "stat -L {}"
fi

init preview_file \
  "( $is_binary && $preview_binary || $preview_text )"
init find_mode_preview \
  "[[ -d {} ]] && $preview_directory || $preview_file"

# Grep Commands: Prefer 'rg' over 'grep' so ignored files are not listed
if has rg; then
  disable no_grep_ignore_status
  init grep_nested \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  init grep_shallow \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --max-depth 1 --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  init grep_mode_preview \
    "rg \${BZB_COLOR:+--color} \${BZB_COLOR:+always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --ignore-case --no-messages --context 1 '\${BZB_GREP_QUERY}' '{}'"
else
  enable no_grep_ignore_status
  init grep_nested \
    "grep -r -l -i -s -C 1 '\${BZB_GREP_QUERY}' .\${BZB_HIDDEN+ | grep -v '.*\/\..*'}"
  init grep_shallow \
    "grep -l -i -s -C 1 '\${BZB_GREP_QUERY}' "'$([[ $BZB_HIDDEN ]] && echo "*" || echo "{*,.*}")'
  init grep_mode_preview \
    "grep \${BZB_COLOR:+--color=always} -i -s -C 1 '\${BZB_GREP_QUERY}' {}"
fi
readonly no_grep_ignore_status
disable grep_query

# Quick-launch Command: Used to open targets in their native client
init launch ''
has xdg-open && init launch 'xdg-open'
has open && init launch 'open'

# Prefer -I option to -i for removing files, if available
rm -I '' 2>&1 | grep '\(unrecognized\|invalid\) option' &>/dev/null && \
  init rm_interactive 'rm -ri' || rm_interactive='rm -rI'


# FILE STATE

save_selection() {
  if [[ $no_edit && -d $data_dir ]]; then
    selection="$data_dir/selection"
    mkdir -p "$(dirname $selection)" && touch "$selection"
    if [[ -w "$selection" ]]; then
      > "$selection"
      for t in "$@"; do
        if [[ -r "$t" ]]; then
          echo "$PWD/$t" >> "$selection"
        fi
      done
    fi
  fi
}

save_session() {
  if [[ -n "$1" ]]; then
    mkdir -p "$(dirname $1)" && touch "$1"
    if [[ -w "$1" ]]; then
      session="$1"
      readarray -t bookmarks < <(dirs -p -l)
      # Write session data to file
      declare -p PWD > "$session"
      [[ "$base_dir" ]] && declare -p base_dir >> "$session"
      [[ "$alt_dir" ]] && declare -p alt_dir >> "$session"
      declare -p bookmarks >> "$session"
      declare -p nested >> "$session"
      declare -p hide >> "$session"
      declare -p ignore >> "$session"
      declare -p sorted >> "$session"
      declare -p reverse >> "$session"
      declare -p preview >> "$session"
    else
      echo "Error: Could not save session to '$1'" 2>&1
      read -s -r -n 1 -p "(Press any key to continue)"
    fi
  fi
}

restore_session() {
  dirs -c
  pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
  for b in "${bookmarks[@]}"; do
    [[ -d "$b" ]] && pushd "$b" >/dev/null
  done
  cd "$base_dir"
}


# MAIN

# Optionally autoload browsing session
init session "${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
[[ $autoload_session && -r "$session" ]] && . -- "$session" && restore_session "$session"


main() {
  # Export variables for use in subshells
  export BZB_BASE_DIR="$base_dir"
  export BZB_QUERY="$query"
  export BZB_COLOR="$color"
  [[ $hide ]] && export BZB_HIDDEN=1 || export BZB_HIDDEN=''
  [[ $ignore ]] && export BZB_NO_IGNORE='' || export BZB_NO_IGNORE=1
  export BZB_REVERSE="$reverse"
  export BZB_GREP_QUERY="$grep_query"

  # Edit file or enter directory
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
    # clear query after changing directory
    export BZB_QUERY=''
  elif [[ $# -ge 1 ]]; then
    edit="${EDITOR:vi}"
    for f in "$@"; do
      edit="$edit '$f'"
    done
    [[ $no_edit ]] && save_selection $@ || bash -c "$edit"
    [[ $once ]] && exit 0
  fi

  # Setup list/sort/preview commands
  [[ $nested ]] && sort="$sort_nested" || sort="$sort_shallow"
  [[ ! $nested || $nested_sort ]] && sort_pipe="${sorted:+ | $sort}" || sort_pipe=''
  if [[ $grep_mode ]]; then
    [[ $nested ]] && grep="$grep_nested" || grep="$grep_shallow"
    preview_opts="--preview='$grep_mode_preview' --preview-window='right:62%:wrap'"
    fzf_input=$(bash -c "echo \"$grep$sort_pipe\"")
    fzf_prompt="/$grep_query/"
    [[ $no_grep_ignore_status ]] && ignore_disabled='!' || ignore_disabled=''
  else
    [[ $nested ]] && find="$find_nested" || find="$find_shallow"
    preview_opts="--preview='$find_mode_preview' --preview-window='right:62%:wrap'"
    fzf_input=$(bash -c "echo \"$find$sort_pipe\"")
    fzf_prompt="${PWD#$base_dir}>"
    [[ $no_find_ignore_status ]] && ignore_disabled='!' || ignore_disabled=''
  fi
  [[ ! $preview ]] && preview_opts=''

  # Prepare display to show status of toggle-settings
  status=()
  [[ $hide ]] && status+=('+hide') || status+=('-hide')
  [[ $ignore ]] && status+=("${ignore_disabled:--}ignore") || status+=("${ignore_disabled:-+}ignore")
  [[ $nested ]] && status+=('+nested') || status+=('-nested')
  [[ $nested_sort ]] && nested_sort_enabled="/" || nested_sort_enabled='' 
  [[ ! $sorted ]] && sort_disabled='-' || sort_disabled=''
  [[ $sorted ]] && sort_enabled='+' || sort_enabled=''
  [[ $nested && $sort_enabled && $parallel_sort ]] && sort_enabled="="
  [[ $nested && ! $nested_sort_enabled ]] && sort_disabled='!' && sort_enabled='!'
  [[ $sorted && $sort_enabled ]] && status+=("${sort_enabled}sort${nested_sort_enabled}") || status+=("${sort_disabled}sort${nested_sort_enabled}")
  [[ ! $sorted || $sort_disabled ]] && reverse_disabled='!' || reverse_disabled=''
  [[ $reverse ]] && status+=("${reverse_disabled:-+}reverse") || status+=("${reverse_disabled:--}reverse")

  export BZB_FZF_HEADER="[${status[@]}]"

  # Clear leading dots from paths
  fzf_input+=" | sed 's:^\./::'"

  fzf_options="${no_clear:+--no-clear} --print-query --multi --layout='reverse' $fzf_bind --expect='$fzf_keys' --query='$BZB_QUERY' --prompt='$fzf_prompt' $preview_opts $fzf_extra_options"
  [[ ! $color ]] && fzf_options="${color:---no-color} $fzf_options"
  [[ $statusline ]] && fzf_options="--header=\"\$BZB_FZF_HEADER\" $fzf_options"

  # CYCLE INTO FZF
  fzf_command="$fzf_input | fzf $fzf_options"
  { read query; read command; readarray -t targets; } < <(bash -c "$fzf_command")

  # Parse empty command and empty target as 'exit' (fzf-native 'escape' or 'ctrl-c' mapping)
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  # Parse empty command as 'enter' action
  [[ -z "$command" ]] && command='right'

  assign action "${key_actions[$command]}"

  next_targets=()

  case $action in
    # Exit grep-mode if any other directory navigation is used
    next-bookmark|next-bookmark2|prev-bookmark|prev-bookmark2|select-bookmark|select-bookmark2|select-nested-bookmark|select-nested-bookmark2|enter-base-dir|prompt-dir|set-base-dir|enter-alt-dir|enter-prev-dir)
      disable grep_mode
    ;;

  # Fall through to remaining cases
  esac; case $action in

    # Use left arrow or ctrl-k to move up a directory, but not above base directory
    # If in grep mode, exit and resume browsing current directory
    back|back2)
      if [[ ! $grep_mode && "$PWD" != "$base_dir" ]]; then
        next_targets=("..")
      else
        next_targets=('.')
        disable grep_mode
      fi
    ;;

    # Use enter or right arrow or ctrl-j to edit file or enter directory
    enter|enter2)
      next_targets=("${targets[@]}")
    ;;

    # Use alt-f to enter grep mode using search pattern specified at prompt
    # Use again to update search pattern. Enter empty pattern to cancel
    grep)
      clear && read -ep "Grep for Pattern: " -i "$grep_query" grep_query
      toggle grep_mode
    ;;

    # Use ctrl-g to toggle in/out of grep mode (not changing search pattern)
    toggle-grep)
      toggle grep_mode
    ;;

    # Use alt-n to toggle listing nested vs only top-level files/directories
    toggle-nested)
      toggle nested
    ;;

    # Use alt-i to toggle visibility of ignored files/directories
    toggle-ignore)
      toggle ignore
    ;;

    # Use alt-h to toggle visibility of hidden files/directories
    toggle-hide)
      toggle hide
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    toggle-sort-order)
      toggle reverse
    ;;

    # Use alt-s to enable/disable sorting
    toggle-sort)
      toggle sorted
    ;;

    # Use ctrl-alt-n to enable/disable nested sorting
    toggle-nested-sort)
      toggle nested_sort
    ;;

    # Use alt-v to toggle visibility of preview pane
    toggle-preview)
      toggle preview
    ;;

    # Use alt-l to toggle visibility of statusline
    toggle-statusline)
      toggle statusline
    ;;

    # Use ctrl-alt-r to restore default settings
    # TODO: Account for initial user preferences from config vars and command line options
    restore-settings)
      enable sorted preview statusline hide ignore
      disable nested reverse
      [[ $parallel_sort ]] && enable nested_sort || disable nested_sort
    ;;

    # Use alt-q to quick-launch targets in their native client
    launch)
      if [[ "$launch" ]]; then
        for t in "${targets[@]}"; do
          bash -c "$launch '$t'"
        done
      fi
    ;;

    # Use alt-r to rename targets in current directory
    rename)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          clear && read -ep 'Move/Rename File: ' -i "mv \"$t\" \"$t\"" cmd
          [[ -n "$cmd" ]] && bash -c "$cmd"
        fi
      done
    ;;

    # Use alt-m to move targets
    move)
      clear && read -ep 'Move to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && mv -i "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-m to move and rename targets
    move-rename)
      clear && read -ep 'Move/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Move/Rename File: ' -i "mv '$PWD/$t' '${dir%/}/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-x to delete targets
    delete)
      CMD="$rm_interactive"
      for t in "${targets[@]}"; do
        CMD="$CMD '$t'"
      done
      clear && bash -c "$CMD"
    ;;

    # Use alt-c to copy targets
    copy)
      clear && read -ep 'Copy to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && cp -ir "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-c to copy and rename targets
    copy-rename)
      clear && read -ep 'Copy/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            clear && read -ep 'Copy/Rename File: ' -i "cp -ir '$PWD/$t' '$dir/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-d to create directory named at prompt
    # Use ctrl-alt-d to create directory and enter it
    create-dir|create-enter-dir)
      [[ "$action" = "create-enter-dir" ]] && create_enter="Create/Enter" || create_enter="Create"
      clear && read -p "$create_enter directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = "${action_keys[create-enter-dir]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-t to "touch" or create file named at prompt
    # Use ctrl-alt-t or alt-e to create file and edit it immediately
    create-file|create-edit-file|create-edit-file2)
      [[ "$action" = "create-edit-file" ]] && create_edit="Create/Edit" || create_edit="Create"
      clear && read -p "$create_edit file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = "${action_keys[create-edit-file]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to toggle bookmark for current directory
    toggle-bookmark)
      if [[ "$(dirs -l)" =~ " $PWD" ]]; then
        for b in ${bookmarks[@]}; do
          if [[ "$dir" = "$b" ]]; then
            popd -n +$i >/dev/null
          fi
        done
      else
        pushd "$dir" >/dev/null
      fi
    ;;

    # Use ctrl-alt-b to bookmark targets
    bookmark-targets)
      dir="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$dir/$b" ]]; then
          cd "$dir/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$dir"
    ;;

    # Use ctrl-alt-u to select bookmarks to delete
    unbookmark)
      current_dir="$PWD"
      # base_dir must stay bookmarked and is omitted from selection menu
      readarray -t dirs < <(dirs -p -l | sed -n '/^'"${base_dir//\//\\/}"'$/!p')
      bookmarks=("$(printf '%s\n' "${dirs[@]# $base_dir}" | LC_ALL=C sort -u | fzf $fzf_submenu_bind --multi --prompt='[unbookmark]')")
      for b in ${bookmarks[@]}; do
        for i in "${!dirs[@]}"; do
          if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$b" ]]; then
            popd -n +$i >/dev/null
          fi
        done
      done
      cd "$current_dir"
    ;;

    # Use alt-right or alt-j to go to next bookmarked directory
    next-bookmark|next-bookmark2)
      cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      fi
    ;;

    # Use alt-left or alt-k to go to previous bookmarked directory
    prev-bookmark|prev-bookmark2)
      cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      fi
    ;;

    # Use alt-up or ctrl-alt-k to select bookmarked directory using fzf
    select-bookmark|select-bookmark2)
      # Omit current directory from bookmarks and position it as initial selection at bottom of list
      readarray -t dirs < <(dirs -p -l | sed -n '/^'"${PWD//\//\\/}"'$/!p' | LC_ALL=C sort -u)
      dirs=("$PWD" ${dirs[@]})
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf $fzf_submenu_bind --prompt='[go to directory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-down or ctrl-alt-j to select bookmarked directory under current directory
    select-nested-bookmark|select-nested-bookmark2)
      readarray -t dirs < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf $fzf_submenu_bind --prompt='[go to subdirectory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-z to go to previous directory
    enter-prev-dir)
      cd "$OLDPWD"
    ;;

    # Use alt-a to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    # Use ctrl-alt-a to set alternate directory
    set-alt-dir|enter-alt-dir)
      if [[ "$action" = "set-alt-dir" || ! -d "$alt_dir" ]]; then
        clear && read -ep "Set alternate directory: " -i "$PWD" dir
        [[ -d "$dir" ]] && alt_dir="${dir%/}" || echo "Not a directory"
      fi
      if [[ "$action" = "enter-alt-dir" && -d "$alt_dir" ]]; then
        [[ "$PWD" = "$alt_dir" ]] && cd "$OLDPWD" || cd "$alt_dir"
      fi
    ;;

    # Use alt-g to go to directory named at prompt
    prompt-dir)
      clear && read -ep "Go to directory: " -i "$PWD" dir
      [[ -d "$dir" ]] && cd "$dir" || echo "Not a directory"
    ;;

    # Use ctrl-alt-g to set/enter new base directory
    # Use alt-u to go "up" to base directory, or go back
    # to previous directory if already in base directory
    set-base-dir|enter-base-dir)
      dir="$PWD"
      if [[ "$action" = "set-base-dir" || ! -d "$base_dir" ]]; then
        clear && read -ep "Set base directory: " -i "$dir" dir
        if [[ -d "$dir" ]]; then
          base_dir="${dir%/}"
          pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
          session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
          assign action "autoload-session"
        fi
      fi
      if [[ ! -d "$base_dir" || ! -d "$dir" ]]; then
        echo "Error: Cannot set base directory to invalid path" 2>&1
        read -s -r -n 1 -p "(Press any key to continue)"
      elif [[ "$action" = "enter-base-dir" && "$PWD" = "$base_dir" ]]; then
        cd "$OLDPWD"
      else
        cd "$base_dir"
      fi
    ;;

  # Fall through to remaining cases
  esac; case $action in

    # Use ctrl-alt-l to load session. May be triggered automatically by other actions,
    # in which case prompt will still appear if autoload_session setting is disabled
    load-session|autoload-session)
      restore="$session"
      if [[ "$action" = 'load-session' || ! $autoload_session ]]; then
        clear && read -ep "Load session: " -i "$restore" restore
      fi
      if [[ -r "$restore" ]]; then
        session="$restore"
        . -- "$session"
        restore_session
      fi
    ;;

    # Use ctrl-alt-s to save session
    save-session)
      clear && read -ep "Save session: " -i "$session" save
      save_session "$save"
    ;;
  esac

  # Optionally autosave browsing session
  [[ "$autosave_session" ]] && save_session "$session"

  main "${next_targets[@]}"
}

# Default initial target is current directory
main "${initial_target:-$base_dir}"
