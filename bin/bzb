#!/usr/bin/env bash
# File:         bzb
# Description:  Browse files using fzf.
# Version:      0.0.1
# License:      Copyright 2020-2021 Brian Dellaterra.
#               Distributed under the terms of the GNU Lesser General Public License Version 2.1.
#               See the file LICENSE or <http://www.gnu.org/licenses/>.
set -e; shopt -s extglob expand_aliases

script_version='0.0.1'
script_name=$(basename "${BASH_SOURCE[0]}")


# COMPATIBILITY

if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
  echo "Error: $script_name requires a newer version of bash" 1>&2
  exit 1
else
  # Avoid polluting export namespace for global variables if declare supports -g option (bash version 4.2+)
  [[ "${BASH_VERSINFO[0]}" -eq 4 && "${BASH_VERSINFO[1]}" -lt 2 ]] && alias global='export' || alias global='declare -g'
fi


# FUNCTIONS

# Test if command exists
has() { command -v "$1" &>/dev/null; }

# Test if variable is defined
defined() { [[ -n "$1" && -n "${!1+defined}" ]] || return 1; }

# Set global variable with name matching first argument to value provided as second argument
# Variables prefixed with 'BZB_' are always exported
assign() {
  local var="$1"; shift;
  [[ "$var" =~ ^BZB_ ]] && export "$var"
  global $var="$*"
}

# In the variable name provided as first argument, store the default value provided
# as second argument. If BZB_ prefixed all-caps variable is defined use its value instead
init() {
  local var="$1"; shift;
  override="BZB_${var^^}"
  defined "$override" && assign "$var" "${!override}" || assign "$var" "$*"
}

# Initialize all variable names provided to true/on,
# allowing override by BZB_ prefixed all-caps variable only if previously unset
enable() {
  for var in "$@"; do
    defined "$var" && assign "$var" 1 || init "$var" 1
  done
}

# Initialize all variable names provided to false/off,
# allowing override by BZB_ prefixed all-caps variable only if previously unset
disable() {
  for var in "$@"; do
    defined "$var" && assign "$var" '' || init "$var" ''
  done
}

# Enable setting if disabled. Disable it if enabled
toggle() { [[ ${!1} ]] && disable "$1" || enable "$1"; }

# Escape single-quotes to make a single-quotable string
sq() { printf '%s' "${1//\'/\'\\\'\'}"; }

# Escape special chars and newlines to make a double-quotable string
dq() { printf '%s' "$1" | sed -e 's/[$!&`"\]/\\&/g'; }

# Get relative path from source file/directory (1st arg) to target file/directory (2nd arg)
# Can supply non-existant directories (not files) for either arg if using absolute path
_rel_down() {
  [[ "$1" = '/' && ! "$2" = '/' ]] && local pre='./' || local pre='.'
  [[ "${2%/}/" =~ ^"${1%/}/" ]] && echo "$pre${2#"$1"}"
}
_rel_up() {
  while [[ ! "$(_rel_down "$1" "$2")" ]]; do
    set -- "$(dirname "$1")" "$2" 
    local back="../$back" rest="${2#"$1"}"
  done
  echo "$back${rest#/}"
}
rel() {
  local source=$(printf '%q' "$1") target=$(printf '%q' "$2") source_file='' target_file=''
  [[ ! "$source" =~ \.*\/ ]] && source="./$source"
  [[ ! "$target" =~ \.*\/ ]] && target="./$target"
  [[ -f "$source" ]] && source_file="$(basename "$source")" source="$(dirname "$source")"
  [[ -f "$target" ]] && target_file="$(basename "$target")" target="$(dirname "$target")"
  [[ -d "$source" && ! "$source" = '/' ]] && source="$(readlink -f "${source%/}")" || source="${source/%%+(/)}"
  [[ -d "$target" && ! "$target" = '/' ]] && target="$(readlink -f "${target%/}")" || target="${target/%%+(/)}"
  local rel="$(_rel_down "$source" "$target")"; 
  [[ ! $rel ]] && rel="$(_rel_up "$source" "$target")"
  [[ $target_file ]] && rel="${rel%%+(/)}/$target_file"
  echo "$rel"
}

display_error() {
  echo && last_error=$(printf 'Error: %s' "$@" 2>&1 | tee /dev/tty) && echo;
  [[ ! $autoplay ]] && read -s -r -n 1 -p "(Press any key to continue)";
}

# Leave alternate screen manually on exit after using fzf '--no-clear' option
clear_fzf() { [[ $fzf_command && $no_clear ]] && tput rmcup; }


# BINDINGS

# Set readline keybinds for cancelling prompts with ctrl-g or double-escape
# Binding single-escape could cause side effects due to its use as a common meta character
bind '"\C-g":"\C-k\C-u
"' '"\e\e":"\C-g"' &>/dev/null

# Set fzf keybinds for movement and exit actions (Avoid spaces or quotes for these assignments)
init fzf_bind '--bind=ctrl-g:ignore,esc:cancel'
init fzf_submenu_bind '--bind=ctrl-g:unix-line-discard+print-query,esc:unix-line-discard+print-query'

# Read overrides for action/key bindings
eval "declare -A BZB_BIND=( $BZB_BIND )"

declare -A key_definitions key_actions action_keys is_recordable is_executable
map() {
  [[ "${BZB_BIND[$1]+defined}" ]] && key="${BZB_BIND[$1]}" || key="$2"
  if [[ $key ]]; then
    keys[${#keys[@]}]="$key"
    key_definitions["$key"]="$3$4"
    key_actions["$key"]="$1"
    action_keys["$1"]="$key"
  fi
  # 4th field of '*' indicates action is not recordable. Double '**' means it's recorded as 'execute' action(s)
  [[ "$4" =~ ^\* ]] && is_recordable["$1"]='' || is_recordable["$1"]=1
  [[ "$4" =~ ^\*\* ]] && is_executable["$1"]=1 || is_executable["$1"]=''
}

map 'exit'                    'esc'         "exit file browser"
map 'enter'                   'right'       "enter directory or edit file"
map 'back'                    'left'        "go to parent directory (not moving past base directory)"
map 'launch'                  'alt-q'       "(q)uick-launch targets using default program"
map 'grep'                    'alt-f'       "grep/(f)ind pattern specified at prompt ('left' will exit grep mode)"
map 'toggle-grep'             'ctrl-g'      "cancel submenu or prompt / toggle (g)rep mode preserving pattern"
map 'move'                    'alt-m'       "(m)ove targets to directory named at prompt"
map 'rename'                  'alt-r'       "(r)ename targets in current directory"                          '**'
map 'move-rename'             'ctrl-alt-m'  "(m)ove/rename targets into directory named at prompt"           '**'
map 'delete'                  'alt-x'       "delete targets"
map 'copy'                    'alt-c'       "(c)opy targets to directory named at prompt"
map 'copy-rename'             'ctrl-alt-c'  "(c)opy/rename targets into directory named at prompt"           '**'
map 'create-file'             'alt-t'       "create (a.k.a. \"(t)ouch\") file named at prompt"
map 'create-edit-file'        'alt-e'       "create and (e)dit file named at prompt"
map 'create-dir'              'alt-d'       "create (d)irectory named at prompt"
map 'create-enter-dir'        'ctrl-alt-d'  "create/enter (d)irectory named at prompt"
map 'toggle-bookmark'         'alt-b'       "toggle (b)ookmark for current directory"
map 'bookmark-targets'        'ctrl-alt-b'  "(b)ookmark targets"
map 'unbookmark'              'ctrl-alt-u'  "(u)nbookmark selected directories"                              '*'
map 'prev-bookmark'           'alt-left'    "jump backward through list of bookmarks"
map 'prev-bookmark2'          'alt-k'       "jump bac(k)ward through list of bookmarks"
map 'next-bookmark'           'alt-right'   "jump forward through list of bookmarks"
map 'next-bookmark2'          'alt-j'       "(j)ump forward through list of bookmarks"
map 'select-bookmark'         'alt-up'      "select and enter bookmarked directory"                          '*'
map 'select-bookmark2'        'ctrl-alt-k'  "select and enter bookmarked directory"                          '*'
map 'select-nested-bookmark'  'alt-down'    "select and enter bookmarked directory under current directory"  '*'
map 'select-nested-bookmark2' 'ctrl-alt-j'  "select and enter bookmarked directory under current directory"  '*'
map 'enter-alt-dir'           'alt-a'       "switch between current and (a)lternate directory"
map 'set-alt-dir'             'ctrl-alt-a'  "set (a)lternate directory (default for copy/move prompts)"
map 'up-base-dir'             'alt-u'       "go to base directory, or if at base move it (u)p one level"
map 'enter-prev-dir'          'alt-p'       "switch between current and (p)revious directory"
map 'prompt-dir'              'alt-g'       "(g)o to directory named at prompt"
map 'prompt-base-dir'         'ctrl-alt-g'  "set new base directory at prompt and (g)o to it"
map 'yank-dir'                'alt-y'       "copy (a.k.a. (y)ank) current directory to clipboard"
map 'yank-targets'            'ctrl-alt-y'  "copy (a.k.a. (y)ank) targets to clipboard"
map 'zip'                     'alt-z'       "compress (a.k.a. (z)ip) targets"
map 'unzip'                   'ctrl-alt-z'  "decompress (a.k.a. un(z)ip) targets"
map 'toggle-statusline'       'alt-l'       "toggle visibility of the status(l)ine"
map 'toggle-hide'             'alt-h'       "toggle visibility of (h)idden files"
map 'toggle-ignore'           'alt-i'       "toggle visibility of (i)gnored files (if supported)"
map 'toggle-nested'           'alt-n'       "toggle listing (n)ested vs. only top-level files"
map 'toggle-sort'             'alt-s'       "toggle (s)orting of results (affects performance)"
map 'toggle-nested-sort'      'ctrl-alt-n'  "toggle sorting of (n)ested results (affects performance)"
map 'toggle-sort-order'       'alt-o'       "toggle sort (o)rder ascending/descending"
map 'initial-settings'        'ctrl-alt-i'  "restore (i)nitial view/sort settings"
map 'toggle-preview'          'alt-v'       "toggle visibility of pre(v)iew pane"
map 'toggle-full-path'        'ctrl-alt-f'  "toggle (f)ull/relative path for files and directories"
map 'toggle-recording'        'ctrl-alt-r'  "(r)ecord actions to file named at prompt"                       '*'
map 'toggle-playback'         'ctrl-alt-p'  "(p)layback actions from file named at prompt"                   '*'
map 'load-session'            'ctrl-alt-l'  "(l)oad session from file named at prompt"
map 'save-session'            'ctrl-alt-s'  "(s)ave session to file named at prompt"
map 'terminal'                'ctrl-alt-t'  "open a new (t)erminal/shell in current directory"               '**'
map 'execute'                 'ctrl-alt-x'  "e(x)ecute a single shell command in current directory"          '**'

# Comma-separated list of custom mappings for fzf
readonly fzf_keys="esc,$(printf ",%s" "${keys[@]}" | cut -c2-)"


# ABOUT

version() {
  echo "$script_name $script_version"
}

usage() {
cat <<USAGE
usage: $script_name [options] [target file or directory]

Browse files using fzf. If no target is specified start in the current directory.

Options:

--color,-c                         Show colorized output
--nested,-n                        List nested files/directories at start
--no-hide,-H                       Show hidden files/directories at start
--no-ignore,-I                     Show ignored files/directories at start
--reverse,-O                       Reverse the normal sort order
--no-sort,-S                       Disable sorting of files/directories (affects performance)
--no-nested-sort,-NS               Disable sorting of nested files/directories (affects performance)
--no-statusline,-L                 Disable statusline that shows current state of various settings
--no-preview,-V                    Disable preview pane that shows file/directory contents
--no-persist,-P                    Exit browser after editing a file
--no-edit,-E                       Log selections to file instead of launching editor
--no-full-path,-F                  Use relative paths instead of full/absolute paths
--autosave-history,-ah             Save queries so Ctrl-p and Ctrl-n will cycle through search history
--autoload-query,-aq               Restore last query used in a directory upon entering it
--autosave-session,-as             Save bookmarks and view/sort settings continuously
--autoload-session,-al             Load bookmarks and view/sort settings on entering base directory
--autorecord,-ar                   Enable automatically recording actions to a file at start
--autoplay,-ap                     Enable automatically playing actions from a file at start
--recording-file=FILE,-rf=FILE     Specify target file for saving recorded actions
--playback-file=FILE,-pf=FILE      Specify source file for playing recorded actions
--base-directory=DIR,-bd=DIR       Specify base directory instead of deriving it from target argument
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start
--data-directory=DIR,-dd=DIR       Specify directory for storing sessions and other data
--grep=PATTERN,-g=PATTERN          Start in grep mode, searching files for specified pattern
--no-nested-grep,-NG               Disable searching of nested files/directories in grep mode
--debug                            Show additional messages and error output
--help                             Show this help text
--version                          Display version number

Most options can be inverted by reversing uppercase/lowercase for the short form or adding/removing
the 'no-' prefix for the long form. Additional options will be passed on to fzf, with the long form using
an equals sign required for options that take values, unless no unescaped spaces are used in the assignment.
example: '--query=STR' or '-qSTR', not '-q STR'

Key mappings:

$(awk -F ':' '{ printf("%-12s %-69s %s\n", $1, $2, $3) }' <(
cat <<KEY_USAGE
KEY:DESCRIPTION:ACTION
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${keys[@]}"; do echo "$k:${key_definitions[$k]}:${key_actions[$k]}"; done)
KEY_USAGE
))

Overrides for action/key bindings can be set using environment variable BZB_BIND.
For example, the 'launch' and 'enter' bindings can be swapped by invoking bzb with command:
> BZB_BIND="[enter]=alt-q [launch]=right" bzb

Some functionality is not available during recording. If errors are detected the action will be
recorded as a '#' comment including the error. Comment lines are skipped during playback.

*  Designated actions are not recordable.
** Each terminal command will be recorded as a separate 'execute' action
USAGE
}


# OPTIONS

for arg in "$@"; do
  case $arg in
    --debug) enable BZB_DEBUG; shift ;;
    --help) usage; exit 0 ;;
    --version) version; exit 0 ;;
    -c|--color) enable BZB_COLOR; shift ;;
    -C|--no-color) disable BZB_COLOR; shift ;;
    -n|--nested) enable BZB_NESTED; shift ;;
    -N|--no-nested) disable BZB_NESTED; shift ;;
    -h|--hide) enable BZB_HIDE; shift ;;
    -H|--no-hide) disable BZB_HIDE; shift ;;
    -i|--ignore) enable BZB_IGNORE; shift ;;
    -I|--no-ignore) disable BZB_IGNORE; shift ;;
    -o|--forward) disable BZB_REVERSE; shift ;;
    -O|--reverse) enable BZB_REVERSE; shift ;;
    -s|--sort) enable BZB_SORTED; shift ;;
    -S|--no-sort) disable BZB_SORTED; shift ;;
    -ns|--nested-sort) enable BZB_NESTED_SORT; shift ;;
    -NS|--no-nested-sort) disable BZB_NESTED_SORT; shift ;;
    -l|--statusline) enable BZB_STATUSLINE; shift ;;
    -L|--no-statusline) disable BZB_STATUSLINE; shift ;;
    -v|--preview) enable BZB_PREVIEW; shift ;;
    -V|--no-preview) disable BZB_PREVIEW; shift ;;
    -p|--persist) enable BZB_PERSIST; shift ;;
    -P|--no-persist) disable BZB_PERSIST; shift ;;
    -e|--edit) enable BZB_EDIT; shift ;;
    -E|--no-edit) disable BZB_EDIT; shift ;;
    -f|--full-path) enable BZB_FULL_PATH; shift ;;
    -F|--no-full-path) disable BZB_FULL_PATH; shift ;;
    -ah|--autosave-history) enable BZB_AUTOSAVE_HISTORY; shift ;;
    -AH|--no-autosave-history) disable BZB_AUTOSAVE_HISTORY; shift ;;
    -aq|--autoload-query) enable BZB_AUTOLOAD_QUERY; shift ;;
    -AQ|--no-autoload-query) disable BZB_AUTOLOAD_QUERY; shift ;;
    -as|--autosave-session) enable BZB_AUTOSAVE_SESSION; shift ;;
    -AS|--no-autosave-session) disable BZB_AUTOSAVE_SESSION; shift ;;
    -al|--autoload-session) enable BZB_AUTOLOAD_SESSION; shift ;;
    -AL|--no-autoload-session) disable BZB_AUTOLOAD_SESSION; shift ;;
    -ar|--autorecord) enable BZB_AUTORECORD; shift ;;
    -AR|--no-autorecord) disable BZB_AUTORECORD; shift ;;
    -ap|--autoplay) enable BZB_AUTOPLAY; shift ;;
    -AP|--no-autoplay) disable BZB_AUTOPLAY; shift ;;
    -rf=*|--recording-file=*=*) assign BZB_RECORDING_FILE "${arg#*=}"; shift ;;
    -pf=*|--playback-file=*=*) assign BZB_PLAYBACK_FILE "${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) assign BZB_BASE_DIR "${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) assign BZB_ALT_DIR "${arg#*=}"; shift ;;
    -dd=*|--data-dir=*|--data-directory=*) assign BZB_DATA_DIR "${arg#*=}"; shift ;;
    -g=*|--grep=*) enable BZB_GREP_MODE; assign BZB_GREP_QUERY "${arg#*=}"; shift ;;
    -ng|--nested-grep) enable BZB_NESTED_GREP; shift ;;
    -NG|--no-nested-grep) disable BZB_NESTED_GREP; shift ;;
    # Save remaining options for fzf with quoting preserved
    -*) [[ "$arg" == *=* ]] && BZB_FZF_EXTRA_OPTIONS+=" ${arg%%=*}=\"${arg#*=}\"" || BZB_FZF_EXTRA_OPTIONS+=" \"$arg\""; shift ;;
  esac
done


# ARGUMENTS

initial_target="$1"
initial_targets=("$@") 


# SETTINGS

# Detect terminal/color-support and exit if not interactive
if [[ -t 0 || -p /dev/stdin ]]; then
  if has tput; then
    [[ ! $BZB_DEBUG ]] && enable no_clear && readonly no_clear
    trap clear_fzf EXIT
    test $(tput colors) -ge 8 && enable color || disable color
  fi
else
  echo "Error: $script_name must be run interactively" 1>&2
  exit 1
fi
fzf_no_clear="${no_clear:+--no-clear}"
[[ $color ]] && fzf_color='--color' || fzf_color='--no-color'

# Default behavior is to launch $EDITOR as the enter-action for files. Disabling the option
# below will instead only log selected targets to a 'selection' file inside 'data_dir'.
# This helps communicate user actions to an external program that has launched bzb as an
# integrated file browser. Disabling this option will also disable the 'persist' option
enable edit

# Default enabled/disabled settings
[[ $edit ]] && enable persist || disable persist
enable sorted preview statusline hide ignore nested_grep full_path
disable nested reverse autosave_history autoload_query autosave_session autoload_session autorecord autoplay grep_mode fzf_extra_options

# Derive base directory from target, or use current directory if none given
[[ -d "$initial_target" ]] && init base_dir "$initial_target" || init base_dir "$(dirname "${initial_target:-$PWD/.}")"
[[ ! "$(dirs -l)" =~ " $base_dir" ]] && pushd "$base_dir" >/dev/null && pushd +1 >/dev/null

# Alternate directory for quick naviagtion and file-operations (Undefined by default)
disable alt_dir


# COMMANDS

# Find Commands: Prefer 'fd' over 'find' so ignored files are not listed
if has fd; then
  enable find_can_ignore
  init find_nested \
    "fd \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
  init find_shallow \
    "fd --max-depth 1 \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
else
  disable find_can_ignore
  init find_nested \
    "find . -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
  init find_shallow \
    "find . -maxdepth 1 -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
fi
readonly find_can_ignore

# Sort Command:
enable parallel_sort
init sort_shallow \
  "LC_ALL=C sort \$([[ \$BZB_SORT_NUMERIC ]] && echo '-g' || echo '-fiu') \${BZB_REVERSE:+-r}"
if has parallel && test "$parallel_sort"; then
  enable nested_sort
  init sort_nested \
    "LC_ALL=C parallel --pipe --block 64k sort \$([[ \$BZB_SORT_NUMERIC ]] && echo '-g' || echo '-fiu') \${BZB_REVERSE:+-r} 2>/dev/null"
else
  disable parallel_sort nested_sort
  init sort_nested "$sort_shallow"
fi
readonly parallel_sort

# Non-adjacent Uniq Command:
if has nauniq; then
  init non_adj_uniq \
    "nauniq"
elif has perl; then
  init non_adj_uniq \
    "perl -ne '$(sq '!$read{$_}++ && print')'"
else
  # Fall back to regular uniq
  init non_adj_uniq \
    "uniq"
fi

# Preview Commands:
init preview_directory \
  "ls \${BZB_COLOR:+--color=always} \${BZB_HIDDEN:+-a} -lh {}"
init preview_text \
  "cat {}"
# Consider file to be binary if more than a tiny fraction is non-printable characters
init is_binary \
  '( test $(head -qc 8192 {} 2>/dev/null | grep -so "[^[:print:]]" 2>/dev/null | wc -c) -gt 16 )'

if has file; then
  init preview_binary_file \
    "file -L {}"
  init is_binary \
    "( $is_binary"' || ( file -L {} | grep -q "compressed") )'
else
  init preview_binary_file \
    "stat -L {}"
fi

if has less; then
  init is_previewable_binary_content \
    '[[ $(bash -c "$(printf "$LESSOPEN" {})") ]]'
  init preview_binary_content \
    'echo && less {}'
else
  disable is_previewable_binary_content preview_binary_content
fi

[[ $is_previewable_binary_content && $preview_binary_content ]] && init \
  preview_binary_file "( $preview_binary_file && $is_previewable_binary_content && $preview_binary_content )"
init preview_file \
  "( ! $is_binary && $preview_text || $preview_binary_file )"
init find_mode_preview \
  "[[ -d {} ]] && $preview_directory || $preview_file"

# Clear leading dots from paths
no_leading_dots="| sed 's:^\./::'"

# Clear numeric count from beginning of grep results
no_grep_counts="| sed -e 's/^[0-9]\+ //g'"

# Grep Commands: Prefer 'rg' over 'grep' so ignored files are not listed. (Uses '-c' for number of matches per file)
no_zero_counts="| grep -v ':0$'"
list_by_grep_count="$no_zero_counts | awk -F ':' '$(dq "$(sq '{ printf( "%s %s\n", $2, $1 ) }')")'"
escape_grep_results="| sed -e '$(sq 's/\s\|'\''/\\\&/g')'"
if has rg; then
  enable grep_can_ignore
  init grep_nested \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --count --ignore-case --no-messages '\${BZB_GREP_QUERY}' . $no_leading_dots $list_by_grep_count"
  init grep_shallow \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --count --maxdepth 1 --ignore-case --no-messages '\${BZB_GREP_QUERY}' . $no_leading_dots $list_by_grep_count "
  init grep_mode_preview \
    "echo {} $no_grep_counts $escape_grep_results | xargs cat | rg \${BZB_COLOR:+--color} \${BZB_COLOR:+always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --ignore-case --no-messages --context 1 '\${BZB_GREP_QUERY}'"
else
  disable grep_can_ignore
  init grep_nested \
    "grep -r -i -s -c '\${BZB_GREP_QUERY}' .\${BZB_HIDDEN+ | grep -v '.*\/\..*'}$no_leading_dots $list_by_grep_count"
  init grep_shallow \
    "grep -i -s -c '\${BZB_GREP_QUERY}' "'$([[ $BZB_HIDDEN ]] && echo "*" || echo "{*,.*}")'"$no_leading_dots $list_by_grep_count"
  init grep_mode_preview \
    "echo {} $no_grep_counts $escape_grep_results | xargs cat | grep \${BZB_COLOR:+--color=always} -i -s -C 1 '\${BZB_GREP_QUERY}'"
fi
readonly grep_can_ignore
disable grep_query

# Quick-launch Command: Used to open targets in their native client
init launch ''
has xdg-open && init launch 'xdg-open'
has open && init launch 'open'

# Clip Command: Used to copy text to clipboard
init clip ''
has xclip && init clip 'xclip'
has clip && init clip 'clip'

# Zip Commands: Used to compress/decompress files
disable zip_keep # set to 'k' or appropriate flag to keep uncompressed files after zip
if has tar; then
  if has xz; then
    init zip "xz"
    init zip_tar_flag 'J'
    init zip_ext 'xz'
  elif has bzip2; then
    init zip "bzip2"
    init zip_tar_flag 'j'
    init zip_ext 'bz2'
  elif has gzip; then
    init zip "gzip"
    init zip_tar_flag = 'z'
    init zip_ext 'gz'
  fi
  if [[ $zip && $zip_tar_flag ]]; then
    [[ $zip_keep ]] && zip+=" -$zip_keep"
    init unzip "$zip -d$zip_keep"
    init zip_dir 'tar -${zip_tar_flag}${zip_keep}cpvf'
    init unzip_dir 'tar -${zip_tar_flag}xpvf'
    init zip_dir_check 'tar -tf'
  fi
fi

# Prefer -I option to -i for removing files, if available
rm -I '' 2>&1 | grep '\(unrecognized\|invalid\|illegal\) option' &>/dev/null && \
  init rm_interactive 'rm -ri' || init rm_interactive 'rm -rI'


# FILE STATE

# Files for recording and playing back actions (Optional and undefined by default)
disable recording_file
disable playback_file

# Directory/files for saving and restoring session data (Optional feature, disabled by default)
init data_dir "$HOME/.bzb" && readonly data_dir
init session "${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
[[ $autosave_history ]] && init search_history "${data_dir:+$data_dir/sessions$base_dir/search_history.bzb}"
if [[ $search_history ]]; then
  mkdir -p "$(dirname "$search_history")" && touch "$search_history"
  fzf_history+="--history='$(sq "$search_history")'"
  # Eliminate duplicates from history file created by fzf
  bash -c "rm '$(sq "$search_history")' && $non_adj_uniq > '$(sq "$search_history")'" < "$search_history"
fi

# Dictionary for mapping directory to its last search query
declare -A directory_queries

save_selection() {
  if [[ -d "$data_dir" ]]; then
    selection="$data_dir/selection"
    mkdir -p "$(dirname "$selection")" && touch "$selection"
    if [[ -w "$selection" ]]; then
      > "$selection"
      for t in "$@"; do
        if [[ -r "$t" ]]; then
          echo "$PWD/$t" >> "$selection"
        fi
      done
    fi
  fi
}

save_session() {
  if [[ -n "$1" ]]; then
    mkdir -p "$(dirname "$1")" && touch "$1"
    if [[ -w "$1" ]]; then
      session="$1"
      readarray -s 1 -t bookmarks < <(dirs -p -l)
      # Write session data to file
      declare -p PWD > "$session"
      [[ "$base_dir" ]] && declare -p base_dir >> "$session"
      [[ "$alt_dir" ]] && declare -p alt_dir >> "$session"
      declare -p bookmarks hide ignore nested nested_grep sorted nested_sort reverse preview statusline full_path >> "$session"
      [[ "$grep_query" ]] && declare -p grep_query >> "$session"
      [[ ${#directory_queries[@]} ]] && declare -p directory_queries >> "$session"
    else
      display_error "Could not save session to '$1'"
    fi
  fi
}

restore_session() {
  dirs -c
  for b in "${bookmarks[@]}"; do
    [[ -d "$b" && ! "$(dirs -l)" =~ " $b" ]] && pushd "$b" >/dev/null && pushd +1 >/dev/null
  done
  [[ ! "$(dirs -l)" =~ " $base_dir" ]] && pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
  pushd "$base_dir" >/dev/null
}

record() {
  if [[ -w "$recording_file" ]]; then
    if [[ "${is_recordable[${1%=*}]}" ]]; then
      [[ $last_error ]] && error="# ($last_error)" || error=''
      echo $error $@ >> "$recording_file"
    fi
  else
    display_error "Could not record to '$recording_file'"
  fi
}

input() {
  if [[ $autoplay ]]; then
   if [[ $next_input ]]; then
     global $2="$next_input"
   else
     display_error "Cannot play back action with missing input"
     toggle autoplay && main
   fi
  else
    clear && read -rep "$1" -i "$3" "$2"
    [[ $autorecord ]] && global last_input="${!2}" || global last_input=''
  fi
}

input_path() {
  [[ ! $full_path ]] && set -- "$1" "$2" "$(rel "$PWD" "$3")"
  input "$1" "$2" "$(printf "%q\n" "$3")"
  if [[ ${!2} ]]; then
    assign "$2" $(bash -c echo\ "${!2}")
  fi
}

path_error() { display_error "$(
cat << EOF
${1:-Not a directory.}${2:- Use 'Tab' key for path completion.}
Add a backslash '\' before spaces and special characters below:
\ \$ \` ' "
EOF
)"; }

dot() { [[ $full_path ]] && echo "$PWD" || echo '.'; }


# MAIN

# Save initial preferences so they can be restored later
declare -A initial_settings=([sorted]="$sorted" [preview]="$preview" [statusline]="$statusline" [hide]="$hide" [ignore]="$ignore" [nested]="$nested" [nested_grep]="$nested_grep" [reverse]="$reverse" [nested_sort]="$nested_sort" [full_path]="$full_path")

# Optionally autoload browsing session
[[ $autoload_session && -r "$session" ]] && . -- "$session" && restore_session "$session"

main() {
  assign BZB_BASE_DIR "$base_dir"
  assign BZB_QUERY "$query"
  assign BZB_COLOR "$color"
  [[ $hide ]] && enable BZB_HIDDEN || disable BZB_HIDDEN
  [[ $ignore ]] && disable BZB_NO_IGNORE || enable BZB_NO_IGNORE
  assign BZB_REVERSE "$reverse"
  disable BZB_SORT_NUMERIC
  assign BZB_GREP_QUERY "$(sq "$grep_query")" # escaped for single-quoting here

  # Clear any stale selection so it is not read on esc/ctrl-c exit action
  save_selection

  # Edit file or enter directory
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
  elif [[ $# -ge 1 ]]; then
    edit_targets="${EDITOR:vi}"
    for f in "$@"; do
      edit_targets+=" '$(sq "$f")'"
    done
    [[ $edit ]] && bash -c "$edit_targets" || save_selection "$@"
    [[ ! $persist ]] && exit 0
  fi

  # Clear query when changing directory. Alternatively, restore saved query if setting is enabled
  if [[ "$PWD" != "$BZB_DIR" ]]; then
    [[ $autoload_query ]] && assign BZB_QUERY "${directory_queries[$PWD]}" || disable BZB_QUERY
  fi

  # Export current directory
  assign BZB_DIR "$PWD"

  # Setup list/sort/preview commands
  [[ $nested ]] && sort="$sort_nested" || sort="$sort_shallow"
  [[ ! $nested || $nested_sort ]] && sort_pipe="${sorted:+ | $sort}" || sort_pipe=''
  if [[ $grep_mode ]]; then
    # Order grep results by number of matches descending
    enable BZB_SORT_NUMERIC && toggle BZB_REVERSE
    [[ $nested_grep ]] && grep="$grep_nested" || grep="$grep_shallow"
    fzf_prompt=" --prompt='/$BZB_GREP_QUERY/'"
    fzf_input=$(bash -c "echo \"$grep$sort_pipe\"")
    fzf_preview=$(bash -c "echo \"$grep_mode_preview\"")
  else
    [[ $nested ]] && find="$find_nested" || find="$find_shallow"
    fzf_prompt=" --prompt='$(sq "${BZB_DIR#$BZB_BASE_DIR}")>'"   
    fzf_input=$(bash -c "echo \"$find$sort_pipe\"")
    fzf_preview="$find_mode_preview"
  fi
  fzf_input+="$no_leading_dots"

  # Prepare display to show status of toggle-settings
  status=()
  [[ $hide ]] && status+=('-h') || status+=('-H')
  ignore_prefix='-'
  [[ ! $grep_can_ignore && $grep_mode ]] && ignore_prefix='!'
  [[ ! $find_can_ignore && ! $grep_mode ]] && ignore_prefix='!'
  [[ $ignore ]] && status+=("${ignore_prefix}i") || status+=("${ignore_prefix}I")
  if [[ ($nested && ! $grep_mode) || ($nested_grep && $grep_mode) ]]; then
    status+=('-n')
    [[ $parallel_sort ]] && sort_prefix="=" || sort_prefix='-'
    [[ $nested_sort && ! $sorted ]] && sort_prefix='!'
    [[ $nested_sort ]] && status+=("${sort_prefix}ns") || status+=("${sort_prefix}NS")
  else
    status+=('-N')
    [[ $sorted ]] && status+=("-s") || status+=("-S")
  fi
  [[ ! $sorted ]] && reverse_prefix='!' || reverse_prefix='-'
  [[ $reverse ]] && status+=("${reverse_prefix}O") || status+=("${reverse_prefix}o")
  [[ $full_path ]] && status+=("-f") || status+=("-F")

  assign BZB_STATUSLINE "${autorecord:+REC }${autoplay:+PLAY }[${status[@]}]"

  fzf_options="$fzf_no_clear $fzf_color $fzf_bind $fzf_history $fzf_prompt --expect='$(sq "$fzf_keys")' --query='$(sq "$BZB_QUERY")' --print-query --multi --layout='reverse'"
  [[ $grep_mode ]] && fzf_options+=" --nth=2"
  [[ $statusline ]] && fzf_options+=" --header='$(sq "$BZB_STATUSLINE")'"
  [[ $preview ]] && fzf_options+=" --preview='$(sq "$fzf_preview")' --preview-window='right:62%:wrap'"
  [[ $fzf_extra_options ]] && fzf_options+=" $fzf_extra_options"

  if [[ $autoplay ]]; then
    if [[ ! ${#pending_actions} -gt 0 ]]; then
      toggle autoplay && main
    else
      read -a next_action <<< "${pending_actions[0]}"
      pending_actions=("${pending_actions[@]:1}")
      disable next_input
      action="${next_action[0]}"
      if [[ "$action" =~ = ]]; then
        next_input="$(bash -c "echo ${action#*=}")"
        action="${action%=*}"
      fi
      targets=("${next_action[@]:1}")
      # Skip comment lines
      [[ "$action" =~ ^[[:space:]]*# ]] && main
    fi
  else
    # CYCLE INTO FZF
    fzf_command="$fzf_input | fzf $fzf_options"
    [[ $grep_mode ]] && fzf_command+="$no_grep_counts"
    { read -r query; read -r command; readarray -t targets; } < <(bash -c "$fzf_command")

    # Optionally preserve query for current directory
    if [[ $autoload_query ]]; then
      [[ $query || ( ! $query && ${directory_queries[$BZB_DIR]} ) ]] && directory_queries[$BZB_DIR]="$query"
    fi

    # Parse empty command as 'enter' action
    [[ -z "$command" ]] && command='right'

    # Parse empty command and empty target as 'exit' (fzf-native 'ctrl-c' mapping)
    [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && command='esc'

    assign action "${key_actions[$command]}"

    if [[ $autorecord && ! ( "$action" = 'toggle-recording' || "${is_recordable[$action]}" || "${is_executable[$action]}" ) ]]; then
      display_error "Cannot perform action '$action' during recording" && main
    fi
  fi

  next_targets=()

  case $action in
    # Exit grep-mode if any directory navigation action occurs ('back' is a special case below)
    next-bookmark|next-bookmark2|prev-bookmark|prev-bookmark2|select-bookmark|select-bookmark2|select-nested-bookmark|select-nested-bookmark2|up-base-dir|prompt-dir|set-base-dir|prompt-base-dir|enter-alt-dir|enter-prev-dir)
      disable grep_mode
    ;;

  # Fall through to remaining cases
  esac; case $action in

    # Use left arrow to move up a directory, but not above base directory
    # If in grep mode, exit and resume browsing current directory
    back)
      if [[ ! $grep_mode && "$PWD" != "$base_dir" ]]; then
        next_targets=("..")
      else
        next_targets=('.')
        disable grep_mode
      fi
    ;;

    # Use enter or right arrow to edit file or enter directory
    enter)
      next_targets=("${targets[@]}")
    ;;

    # Use alt-f to enter grep mode using search pattern specified at prompt
    # Use again to update search pattern. Enter empty pattern to exit grep mode
    grep)
      input "Grep for Pattern: " next_query "$grep_query"
      if [[ $next_query ]]; then
        enable grep_mode
        grep_query="$next_query"
      else
        disable grep_mode
      fi
    ;;

    # Use ctrl-g to toggle in/out of grep mode (not changing search pattern)
    toggle-grep)
      toggle grep_mode
    ;;

    # Use alt-n to toggle listing nested vs only top-level files/directories
    toggle-nested)
      [[ $grep_mode ]] && toggle nested_grep || toggle nested
    ;;

    # Use alt-i to toggle visibility of ignored files/directories
    toggle-ignore)
      toggle ignore
    ;;

    # Use alt-h to toggle visibility of hidden files/directories
    toggle-hide)
      toggle hide
    ;;

    # Use alt-s to enable/disable sorting
    toggle-sort)
      toggle sorted
    ;;

    # Use ctrl-alt-n to enable/disable nested sorting
    toggle-nested-sort)
      toggle nested_sort
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    toggle-sort-order)
      toggle reverse
    ;;

    # Use alt-v to toggle visibility of preview pane
    toggle-preview)
      toggle preview
    ;;

    # Use alt-l to toggle visibility of statusline
    toggle-statusline)
      toggle statusline
    ;;

    # Use ctrl-alt-f to toggle full/relative paths
    toggle-full-path)
      toggle full_path
    ;;

    # Use ctrl-alt-r to toggle recording actions to file named at prompt (This action is not recordable)
    toggle-recording)
      if [[ $autorecord ]]; then
        toggle autorecord
      else
        [[ -w "$playback_file" && ! $recording_file ]] && file="$playback_file" || file="$recording_file"
        input "Record actions to file: " file "$file" 
        file=$(readlink -f "$file")
        # use rm command to confirm before clearing logfile, overriding default prompt
        [[ -f "$file" ]] && printf "Clear existing file? [Y/n] " && bash -c "$rm_interactive $file 2>/dev/null"
        if [[ $file ]]; then
          mkdir -p "$(dirname "$file")" && touch "$file"
          if [[ ! -w "$file" ]]; then
            display_error "Cannot record. File could not be created or write permission not granted"
          elif [[ $autoplay && "$playback_file" -ef "$file" ]]; then
            display_error "Cannot record to a file that is currently playing back"
          else
            assign recording_file "$file" && toggle autorecord
          fi
        fi
      fi
    ;;

    # Use ctrl-alt-p to playback recording from file named at prompt (This action is not recordable)
    toggle-playback)
      if [[ $autoplay ]]; then
        toggle autoplay
      else
        [[ -r "$recording_file" && ! $playback_file ]] && file="$recording_file" || file="$playback_file"
        input "Playback actions from file: " file "$file" 
        if [[ $file ]]; then
          if [[ ! -r "$file" ]]; then
            display_error "Cannot playback. File does not exist or read permission not granted"
          elif [[ $autorecord && "$recording_file" -ef "$file" ]]; then
            display_error "Cannot playback from a file that is currently recording"
          else
            assign playback_file "$file"
            readarray -t pending_actions < "$playback_file"
            toggle autoplay
          fi
        fi
      fi
    ;;

    # Use ctrl-alt-i to restore initial view/sort settings
    initial-settings)
      for i in "${!initial_settings[@]}"; do
        [[ ${initial_settings[$i]} ]] && enable "$i" || disable "$i"
      done
    ;;

    # Use alt-y to yank current directory to clipboard
    yank-dir)
      if [[ ! "$clip" ]]; then
        clear && display_error "No clipboard command configured. Cannot copy current directory to clipboard"
      else
        yank_directory=" '$(sq "$PWD")'"
        bash -c "echo -n '$(sq "$yank_directory")' | $clip"
      fi
    ;;

    # Use ctrl-alt-y to yank targets to clipboard
    yank-targets)
      if [[ ! "$clip" ]]; then
        clear && display_error "No clipboard command configured. Cannot copy targets to clipboard"
      else
        yank_targets=''
        for t in "${targets[@]}"; do
          yank_targets+=" '$(sq "$(dot)/$t")'"
        done
        bash -c "echo -n '$(sq "$yank_targets")' | $clip"
      fi
    ;;

    # Use alt-q to quick-launch targets in their native client
    launch)
      if [[ ! "$launch" ]]; then
        clear && display_error "No quick-launch command configured. Cannot open targets in exteral program"
      else
        for t in "${targets[@]}"; do
          bash -c "$launch '$t'"
        done
      fi
    ;;

    # Use alt-r to rename targets in current directory
    rename)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          input "Move/Rename File: " cmd "mv '$(sq "$t")' '$(sq "$t")'" 
          if [[ -n "$cmd" ]]; then
            bash -c "$cmd"
            [[ $autorecord && $recording_file ]] && printf "execute %q\n" "$cmd" >> "$recording_file"
          fi
        fi
      done
    ;;

    # Use alt-m to move targets
    move)
      input_path "Move to Directory: " dir "${alt_dir:-$base_dir}" 
      if [[ $dir ]]; then
        [[ -d "$dir" ]] && mv -i "${targets[@]}" "$dir" || path_error
      fi
    ;;

    # Use ctrl-alt-m to move and rename targets
    move-rename)
      input_path "Move/Rename to Directory: " dir "${alt_dir:-$base_dir}" 
      if [[ $dir ]]; then
        if [[ ! -d "$dir" ]]; then
          path_error
        else
          for t in "${targets[@]}"; do
            if [[ -r "$t" ]]; then
              input "Move/Rename File: " cmd "mv '$(sq "$(dot)/$t")' '$(sq "${dir%/}/$t")'" 
              if [[ -n "$cmd" ]]; then
                bash -c "$cmd"
                [[ $autorecord && $recording_file ]] && printf "execute %q\n" "$cmd" >> "$recording_file"
              fi
            fi
          done
        fi
      fi
    ;;

    # Use alt-z to zip targets
    # Use ctrl-alt-z to unzip targets
    zip|unzip)
      if [[ $zip ]]; then
        [[ $autoplay || ! $CONFIRM_TAR_RM ]] && remove="rm -r" || remove="$rm_interactive"
        remove_targets=''
        for t in "${targets[@]}"; do
          if [[ "$action" = 'zip' && -d "$t" ]]; then
            zip_dir_cmd="$zip_dir '$(sq "$t")'.tar.$zip_ext '$(sq "$t")' >/dev/null"
            bash -c "$zip_dir_cmd" && remove_targets+=" '$(sq "$t")'"
          elif [[ "$action" = 'unzip' ]] && $zip_dir_check "$t" >/dev/null; then
            unzip_dir_cmd="$unzip_dir '$(sq "$t")' >/dev/null"
            bash -c "$unzip_dir_cmd" && remove_targets+=" '$(sq "$t")'"
          elif [[ "$action" = 'unzip' && "$t" =~ "$zip_ext"$ ]]; then
            unzip_cmd="$unzip '$(sq "$t")'"
            [[ -r "$t" ]] && bash -c "$unzip_cmd"
          elif [[ "$action" = 'zip' ]]; then
            zip_cmd="$zip '$(sq "$t")'"
            [[ -r "$t" && -w "$t" ]] && bash -c "$zip_cmd"
          fi
        done
        [[ $remove_targets && ! $zip_keep ]] && bash -c "$remove $remove_targets"
      fi
    ;;

    # Use alt-x to delete targets
    delete)
      delete_targets=''
      for t in "${targets[@]}"; do
        delete_targets+=" '$(sq "$t")'"
      done
      [[ $autoplay ]] && remove="rm -r" || remove="$rm_interactive"
      [[ $delete_targets ]] && clear && bash -c "$remove $delete_targets"
    ;;

    # Use alt-c to copy targets
    copy)
      input_path "Copy to Directory: " dir "${alt_dir:-$base_dir}" 
      if [[ $dir ]]; then
        [[ -d "$dir" ]] && cp -ir "${targets[@]}" "$dir" || path_error
      fi
    ;;

    # Use ctrl-alt-c to copy and rename targets
    copy-rename)
      input_path "Copy/Rename to Directory: " dir "${alt_dir:-$base_dir}" 
      if [[ $dir ]]; then
        if [[ ! -d "$dir" ]]; then path_error; else
          for t in "${targets[@]}"; do
            if [[ -r "$t" ]]; then
              input "Copy/Rename File: " cmd "cp -ir '$(sq "$(dot)/$t")' '$(sq "$dir/$t")'" 
              if [[ -n "$cmd" ]]; then
                bash -c "$cmd"
                [[ $autorecord && $recording_file ]] && printf "execute %q\n" "$cmd" >> "$recording_file"
              fi
            fi
          done
        fi
      fi
    ;;

    # Use alt-d to create directory named at prompt
    # Use ctrl-alt-d to create directory and enter it
    create-dir|create-enter-dir)
      [[ "$action" = "create-enter-dir" ]] && create_enter="Create/Enter" || create_enter="Create"
      input "$create_enter directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$action" = "create-enter-dir" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-t to "touch" or create file named at prompt
    # Use alt-e to create file and edit it immediately
    create-file|create-edit-file)
      [[ "$action" = "create-edit-file" ]] && create_edit="Create/Edit" || create_edit="Create"
      input "$create_edit file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$action" = "create-edit-file" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to toggle bookmark for current directory
    toggle-bookmark)
      current_dir="$PWD"
      readarray -s 1 -t bookmarks < <(dirs -p -l)
      if [[ "$(dirs -l)" =~ " $current_dir" ]]; then
        for i in "${!bookmarks[@]}"; do
          if [[ "$current_dir" = "${bookmarks[$i]}" && ! "$current_dir" = "$base_dir" ]]; then
            popd -n +$((i+1)) >/dev/null
          fi
        done
      else
        pushd "$current_dir" >/dev/null && pushd +1 >/dev/null
      fi
    ;;

    # Use ctrl-alt-b to bookmark targets
    bookmark-targets)
      current_dir="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$current_dir/$b" ]]; then
          # Use $PWD for full path
          cd "$current_dir/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$current_dir"
    ;;

    # Use ctrl-alt-u to select bookmarks to delete (This action is not recordable)
    # TODO: Make this action recordable and support relative paths
    unbookmark)
      current_dir="$PWD"
      readarray -s 1 -t bookmarks < <(dirs -p -l)
      # base_dir must stay bookmarked and is omitted from selection menu
      readarray -t bookmarks < <(printf '%s\n' "${bookmarks[@]}" | sed -n '/^'"${base_dir//\//\\/}"'$/!p')
      if [[ ! "${#bookmarks[@]}" -gt 0 ]]; then
        clear && display_error "No bookmarks to delete"
      else
        readarray -t unmarks < <(printf '%s\n' "${bookmarks[@]}" | LC_ALL=C sort -ru | fzf "$fzf_submenu_bind" --multi --prompt='[unbookmark]')
        for b in "${unmarks[@]}"; do
          readarray -t bookmarks < <(dirs -p -l)
          for i in "${!bookmarks[@]}"; do
            [[ $i -ge 1 && "${bookmarks[$i]}" = "$b" ]] && popd -n +"$i" >/dev/null
          done
        done
        cd "$current_dir"
      fi
    ;;

    # Use alt-right or alt-j to go to next bookmarked directory
    next-bookmark|next-bookmark2)
      cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      fi
    ;;

    # Use alt-left or alt-k to go to previous bookmarked directory
    prev-bookmark|prev-bookmark2)
      cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      fi
    ;;

    # Use alt-up or ctrl-alt-k to select bookmarked directory using fzf (This action is not recordable)
    # TODO: Make this action recordable and support relative paths
    select-bookmark|select-bookmark2)
      # Omit current directory from bookmarks then position it as initial selection at bottom of list
      readarray -t dirs < <(dirs -p -l | sed -n '/^'"${PWD//\//\\/}"'$/!p' | LC_ALL=C sort -u)
      dirs=("$PWD" "${dirs[@]}")
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf "$fzf_submenu_bind" --prompt='[go to directory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-down or ctrl-alt-j to select bookmarked directory under current directory (This action is not recordable)
    # TODO: Make this action recordable and support relative paths
    select-nested-bookmark|select-nested-bookmark2)
      readarray -t dirs < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf "$fzf_submenu_bind" --prompt='[go to subdirectory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-p to go to previous directory
    enter-prev-dir)
      cd "$OLDPWD"
    ;;

    # Use alt-a to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    # Use ctrl-alt-a to set alternate directory
    set-alt-dir|enter-alt-dir)
      if [[ "$action" = "set-alt-dir" || ! -d "$alt_dir" ]]; then
        input_path "Set alternate directory: " dir "$(dot)"
        if [[ $dir ]]; then
          [[ -d "$dir" ]] && alt_dir="$(readlink -f "$dir")" || path_error
        elif [[ $alt_dir ]]; then
          read -s -r -n 1 -p "(Press Enter again to clear alternate directory, any other key to cancel)" dir
          [[ ! $dir ]] && alt_dir=""
        fi
      fi
      if [[ "$action" = "enter-alt-dir" && -d "$alt_dir" ]]; then
        [[ "$PWD" = "$alt_dir" ]] && cd "$OLDPWD" || cd "$alt_dir"
      fi
    ;;

    # Use alt-g to go to directory named at prompt
    prompt-dir)
      input_path "Go to directory: " dir "$(dot)"
      if [[ $dir ]]; then
        [[ -d "$dir" ]] && cd "$dir" || path_error
      fi
    ;;

    # Use ctrl-alt-g to set/enter new base directory
    # Use alt-u to go "up" to base directory,
    # shifting up to parent directory if already at base
    prompt-base-dir|up-base-dir)
      dir="$PWD" next_base=''
      if [[ "$action" = "prompt-base-dir" || ! -d "$base_dir" ]]; then
        input_path "Set base directory: " dir "$(dot)"
        [[ -d "$dir" ]] && next_base="$(readlink -f "$dir")"
      elif [[ "$action" = "up-base-dir" ]]; then
        # 'dirname' stops at root directory, returning '/'
        [[ "$PWD" = "$base_dir" ]] && next_base="$(dirname "$dir")" || cd "$base_dir"
      fi
      if [[ $next_base ]]; then
        if [[ ! -d "$next_base" ]]; then
          path_error
        elif [[ "$next_base" != "$base_dir" ]]; then
          base_dir="$(cd "$next_base" && pwd -P)"
          [[ ! "$(dirs -l)" =~ " $base_dir" ]] && pushd "$base_dir" >/dev/null
          session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
          assign action "autoload-session"
        fi
      fi
    ;;

    # Use ctrl-alt-t to open a new terminal/shell in current directory
    # Use ctrl-alt-e to execute a single command
    terminal|execute)
      if [[ $autoplay ]]; then
        /usr/bin/env bash -c "${targets[@]}"
      else
        [[ "$action" = "execute" ]] && QUIT=';PROMPT_COMMAND="exit"' || QUIT=''
        clear
        set +e
        # Trap each command to log previous command, commented out if exit status indicates failure
        rec_trap='export BZB_LAST_EXIT_CODE="$?" BZB_LAST_COMMAND="$BZB_THIS_COMMAND" BZB_THIS_COMMAND="$BASH_COMMAND"'
        rec_trap+=';[[ "'${autorecord:+1}'" && "'${recording_file:+1}'" ]] && ('
        rec_trap+='[[ $BZB_LAST_EXIT_CODE -ne 0 ]] && printf "# (EXIT_CODE $BZB_LAST_EXIT_CODE) "'
        rec_trap+=';[[ $BZB_LAST_COMMAND ]] && printf "execute %q\n" "$BZB_LAST_COMMAND"'
        rec_trap+=') >> '"$(printf '%q' "$recording_file")$QUIT"
        PS1='>> ' /usr/bin/env bash --init-file <(echo trap\ "'$(sq "$rec_trap")'"\ DEBUG)
        set -e
      fi
    ;;

  # Fall through to remaining cases
  esac; case $action in

    # Use ctrl-alt-l to load session. May be triggered automatically by other actions,
    # in which case prompt will still appear if autoload_session setting is disabled
    load-session|autoload-session)
      session_file="$session"
      if [[ "$action" = 'load-session' || ! $autoload_session ]]; then
        input "Load session: " session_file "$session_file"
        [[ $session_file && ! -r "$session_file" ]] && path_error 'Cannot read session file.'
      fi
      if [[ -r "$session_file" ]]; then
        session="$session_file"
        . -- "$session"
        restore_session
      fi
    ;;

    # Use ctrl-alt-s to save session
    save-session)
      input "Save session: " session_file "$session"
      if [[ $session_file ]]; then
        [[ -w "$session_file" ]] && save_session "$session_file" || path_error 'Cannot write session file.'
      fi
    ;;
  esac

  # Optionally record actions to file
  [[ $last_input ]] && last_input="$(printf "=%q" "$last_input")"
  [[ $autorecord && $recording_file ]] && record "$action$last_input" "${targets[@]}"
  disable last_input last_error

  # Optionally autosave browsing session
  [[ $autosave_session ]] && save_session "$session"

  # Loop until terminated
  [[ "$action" = 'exit' ]] && exit 0 || main "${next_targets[@]}"
}

# Default initial target is current directory
main "${initial_target:-$base_dir}" "${initial_targets[@]:1}"
