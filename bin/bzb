#!/bin/bash
set -e

if [[ "${BASH_VERSINFO[0]}" -lt 2 ]]; then
  echo "Error: $(basename "${BASH_SOURCE[0]}") requires a newer version of bash" 1>&2
  exit 1
fi

# bind readline macros for cancelling prompts with ctr-g or double-escape
bind '"\C-g":"\C-k\C-u
"' '"\e\e":"\C-g"' &>/dev/null

# Test if command exists
function HAS() {
  command -v "$1" &>/dev/null
}

# In the variable name provided as first argument, store the default value provided
# as second argument. If BZB_ prefixed all-caps variable is defined use its value instead
INIT() {
  override="BZB_${1^^}"
  [[ -n ${!override+defined} ]] && value="${!override}" || value="$2"
  # Avoid polluting global namespace if bash supports namerefs (version 4.3+)
  if [[ "${BASH_VERSINFO[0]}" -ge 4 && "${BASH_VERSINFO[0]}" -ge 3 ]]; then
    local -n outvar="$1"
    outvar="$value"
  else
    export "$1=$value"
  fi
}

# Leave alternate screen manually on exit after using fzf '--no-clear' option
function clearFZF() {
  [[ $fzf_command && $no_clear ]] && tput rmcup
}

# Detect terminal and exit if not interactive
if [[ -t 0 || -p /dev/stdin ]]; then
  if HAS tput; then
    declare -r no_clear=1
    trap clearFZF EXIT

    # Detect color output
    test $(tput colors) -ge 8 && INIT 'color' 1 || INIT 'color' ''
  fi
else
  echo "Error: $(basename "${BASH_SOURCE[0]}") must be run interactively" 1>&2
  exit 1
fi

# Directory where data for loading/restoring sessions is saved (optional)
INIT 'data_dir' "$HOME/.bzb" && readonly data_dir

# Default behavior is to launch $EDITOR as the enter-action for files. Enabling option below
# will instead only log selected targets to a 'selection' file in data_dir. This communicates
# user-actions to another program that has launched bzb as an integrated file browser.
# Enabling this option implies 'persist' option below is false
INIT 'no_edit' ''

# Stay in browser after editing files
INIT 'persist' 1

# Start with only top-level files/directories displayed
INIT 'shallow' 1

# Don't show hidden files
INIT 'hidden' ''

# Don't show ignored files
INIT 'no_ignore' ''

# Don't start in grep mode
INIT 'grep_mode' ''

# Sort ascending
INIT 'sorted' 1
INIT 'reverse' ''

# Display preview pane
INIT 'preview' 1
INIT 'preview_window' 'right:62%:wrap'

# Save/Load sessions manually
INIT 'autosave_session' ''
INIT 'autoload_session' ''

# Find Commands: Prefer 'fd' over 'find' so ignored files are not listed
if HAS fd; then
  INIT 'find_recursive' \
    "fd \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
  INIT 'find_shallow' \
    "fd --max-depth 1 \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
else
  INIT 'find_recursive' \
    "find . -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
  INIT 'find_shallow' \
    "find . -maxdepth 1 -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
fi

# Sort Command:
INIT 'sort' \
  "LC_ALL=C sort \${BZB_REVERSE:+-r} -fiu"

# Preview Commands:
INIT 'preview_directory' \
  "ls \${BZB_COLOR:+--color=always} \${BZB_HIDDEN:+-a} -lh {}"
INIT 'preview_text' \
  "cat {}"
INIT 'is_binary' \
  'test `head -qc 8192 {} 2>/dev/null | grep -o "[^[:print:]]" 2>/dev/null | wc -c` -gt 16'

if HAS file; then
  INIT 'preview_binary' \
    "file -L {}"
  INIT 'is_binary' \
    '[[ ! "$(file -L {})" =~ 'text' ]] && '"$is_binary"
else
  INIT 'preview_binary' \
    "stat -L {}"
fi

INIT 'preview_file' \
  "( $is_binary && $preview_binary || $preview_text )"
INIT 'find_mode_preview' \
  "[[ -d {} ]] && $preview_directory || $preview_file"

# Grep Commands: Prefer 'rg' over 'grep' so ignored files are not listed
if HAS rg; then
  INIT 'grep_recursive' \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  INIT 'grep_shallow' \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --max-depth 1 --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  INIT 'grep_mode_preview' \
    "rg \${BZB_COLOR:+--color} \${BZB_COLOR:+always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --ignore-case --no-messages --context 1 '\${BZB_GREP_QUERY}' '{}'"
else
  # TODO: Support ignoring hidden files recursively
  INIT 'grep_recursive' \
    "grep -r -l -i -s -C 1 '\${BZB_GREP_QUERY}' ."
  INIT 'grep_shallow' \
    "grep -l -i -s -C 1 '\${BZB_GREP_QUERY}' "'$([[ $BZB_HIDDEN ]] && echo "*" || echo "{*,.*}")'
  INIT 'grep_mode_preview' \
    "grep \${BZB_COLOR:+--color=always} -i -s -C 1 '\${BZB_GREP_QUERY}' {}"
fi

# Quick-launch Command: Used to open targets in their native client
launch=''
HAS xdg-open && INIT 'launch' 'xdg-open'
HAS open && INIT 'launch' 'open'

# Prefer -I option to -i for removing files, if available
rm -I '' 2>&1 | grep '\(unrecognized\|invalid\) option' &>/dev/null && \
  INIT 'rm_interactive' 'rm -ri' || rm_interactive='rm -rI'

declare -A key_definitions key_actions action_keys
MAP() {
  keys[${#keys[@]}]="$2"
  key_definitions["$2"]="$3"
  key_actions["$2"]="$1"
  action_keys["$1"]="$2"
}

MAP 'enter'                   'right'       "enter directory or edit file"
MAP 'enter2'                  'alt-l'       "enter directory or edit file"
MAP 'back'                    'left'        "go to parent directory (not moving past base directory)"
MAP 'back2'                   'alt-h'       "go to parent directory (not moving past base directory)"
MAP 'launch'                  'alt-q'       "quick-launch targets using native client"
MAP 'grep'                    'alt-/'       "grep for pattern specified at prompt ('left' will exit grep mode)"
MAP 'grep2'                   'ctrl-g'      "toggle grep mode / cancel submenu or prompt"
MAP 'move'                    'alt-m'       "move targets to directory named at prompt"
MAP 'rename'                  'alt-r'       "rename targets in current directory"
MAP 'move-rename'             'ctrl-alt-m'  "move/rename targets into directory named at prompt"
MAP 'move-rename2'            'ctrl-alt-r'  "move/rename targets into directory named at prompt"
MAP 'delete'                  'alt-x'       "delete targets"
MAP 'copy'                    'alt-c'       "copy targets to directory named at prompt"
MAP 'copy-rename'             'ctrl-alt-c'  "copy/rename targets into directory named at prompt"
MAP 'create-edit-file'        'alt-e'       "create/edit file named at prompt"
MAP 'create-file'             'alt-f'       "create file without editing"
MAP 'create-dir'              'alt-d'       "create directory named at prompt"
MAP 'create-enter-dir'        'ctrl-alt-d'  "create/enter directory named at prompt"
MAP 'bookmark-targets'        'alt-b'       "bookmark target directories"
MAP 'bookmark-current-dir'    'ctrl-alt-b'  "bookmark current directory"
MAP 'unbookmark-dirs'         'alt-u'       "unbookmark selected directories"
MAP 'unbookmark-current-dir'  'ctrl-alt-u'  "unbookmark current directory"
MAP 'next-bookmark'           'alt-right'   "go to next bookmarked directory"
MAP 'next-bookmark2'          'ctrl-alt-l'  "go to next bookmarked directory"
MAP 'prev-bookmark'           'alt-left'    "go to previous bookmarked directory"
MAP 'prev-bookmark2'          'ctrl-alt-h'  "go to previous bookmarked directory"
MAP 'select-bookmark'         'alt-up'      "select and enter bookmarked directory"
MAP 'select-bookmark2'        'ctrl-alt-k'  "select and enter bookmarked directory"
MAP 'select-nested-bookmark'  'alt-down'    "select and enter bookmarked directory under current directory"
MAP 'select-nested-bookmark2' 'ctrl-alt-j'  "select and enter bookmarked directory under current directory"
MAP 'set-alt-dir'             'alt-s'       "set alternate directory (default for copy/move prompts)"
MAP 'enter-alt-dir'           'alt-a'       "switch between current and alternate directory"
MAP 'enter-base-dir'          'alt-z'       "switch between current and base directory"
MAP 'enter-prev-dir'          'alt-p'       "switch between current and previous directory"
MAP 'prompt-dir'              'alt-g'       "go to directory named at prompt"
MAP 'set-base-dir'            'ctrl-alt-g'  "set new base directory at prompt and go to it"
MAP 'toggle-preview'          'ctrl-alt-p'  "toggle visibility of preview pane"
MAP 'toggle-ignored'          'alt-i'       "toggle visibility of ignored files (if supported)"
MAP 'toggle-hidden'           'alt-v'       "toggle visibility of hidden files"
MAP 'toggle-nested'           'alt-n'       "toggle listing nested vs. only top-level files"
MAP 'toggle-sort-order'       'alt-o'       "toggle sort order ascending/descending"
MAP 'toggle-sort'             'ctrl-alt-s'  "toggle sorted/unsorted results (affects performance)"
MAP 'reset-view'              'ctrl-alt-n'  "restore normal view settings (don't show nested/hidden/ignored)"
MAP 'load-session'            'alt-y'       "load session from file named at prompt"
MAP 'save-session'            'ctrl-alt-y'  "save session to file named at prompt"

# comma-separated list of custom mappings for fzf
fzf_keys="$(printf ",%s" "${keys[@]}" | cut -c2-)"

usage() {
cat <<USAGE
usage: $(basename "${BASH_SOURCE[0]}") [options] [target file or directory]

Browse files using fzf. If no target specified start in the current directory.

Key mappings:

$(awk -F ':' '{ printf("%-12s %-66s %s\n", $1, $2, $3) }' <(
cat <<KEY_USAGE
KEYMAP:DESCRIPTION:ACTION_NAME
escape:exit file browser
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${keys[@]}"; do echo "$k:${key_definitions[$k]}:${key_actions[$k]}"; done)
KEY_USAGE
))

Options:

--help,-h                          Show this help text
--once,-o                          Exit browser after editing a file
--color,-c                         Show colorized output
--recursive,-r                     List nested files/direcories at start
--hidden,-H                        Show hidden files/direcories at start
--no-ignore,-I                     Show ignored files/direcories at start
--no-preview,-P                    Disable preview pane that shows file/directory contents
--no-sort,-S                       Disable sorting of files/directories
--no-edit,-E                       Disable launch of editor and just log selection to file
--reverse-sort,-R                  Reverse the normal sort order
--auto-save-session,-s             Save bookmarks and view/sort settings continuously
--auto-load-session,-l             Load bookmarks and view/sort settings at start
--grep=PATTERN,-g=PATTERN          Start in grep mode, searching files for specified pattern
--base-directory=DIR,-bd=DIR       Specify a base directory instead of deriving it from target
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start

Any additional options will be passed to fzf.
USAGE
}

for arg in "$@"; do
  case $arg in
    -h|--help) usage; exit 0 ;;
    -o|--once) persist=''; shift ;;
    -c|--color) color=1; shift ;;
    -r|--recursive) shallow=''; shift ;;
    -H|--hidden) hidden=1; shift ;;
    -I|--no-ignore) no_ignore=1; shift ;;
    -P|--no-preview) preview=''; shift ;;
    -S|--no-sort) sorted=''; shift ;;
    -E|--no-edit) no_edit=1; persist=''; shift ;;
    -R|--reverse-sort) reverse=1; shift ;;
    -s|--auto-save-session) autosave_session=1; shift ;;
    -l|--auto-load-session) autoload_session=1; shift ;;
    -g=*|--grep=*) grep_mode=1; grep_query="${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) base_dir="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) alt_dir="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    # TODO: Capture non '=' style arguments 
    -*) fzf_opts+=("${arg%%=*}=\"${arg#*=}\""); shift ;;
  esac
done

initial_target="$1"

# Derive base directory from target, or use current directory if none given
if [[ -z "$base_dir" ]]; then
  [[ -d "$initial_target" ]] && base_dir="$initial_target" || base_dir="$(dirname "${initial_target:-$PWD/.}")"
fi
pushd "$base_dir" >/dev/null && pushd +1 >/dev/null

function save_selection() {
  mkdir -p "$(dirname $selection)" && touch "$selection"
  if [[ -w "$selection" ]]; then
    > "$selection"
    for t in "${targets[@]}"; do
      if [[ -r "$t" ]]; then
        echo "$PWD/$t" >> "$selection"
      fi
    done
  fi
}

function save_session() {
  mkdir -p "$(dirname $session)" && touch "$session"
  readarray -t bookmarks < <(dirs -p -l)
  if [[ -w "$session" ]]; then
    declare -p PWD > "$session"
    [[ "$base_dir" ]] && declare -p base_dir >> "$session"
    [[ "$alt_dir" ]] && declare -p alt_dir >> "$session"
    declare -p bookmarks >> "$session"
    declare -p shallow >> "$session"
    declare -p hidden >> "$session"
    declare -p no_ignore >> "$session"
    declare -p sorted >> "$session"
    declare -p reverse >> "$session"
    declare -p preview >> "$session"
  fi
}

function load_session() {
  dirs -c
  pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
  for b in "${bookmarks[@]}"; do
    [[ -d "$b" ]] && pushd "$b" >/dev/null
  done
  cd "$base_dir"
}

if [[ "$autoload_session" ]]; then
  session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
  if [[ -r "$session" ]]; then
    . -- "$session"
    load_session;
  fi
fi

main() {
  # Export variables for use in subshells
  export BZB_QUERY="$query"
  export BZB_COLOR="$color"
  export BZB_HIDDEN="$hidden"
  export BZB_NO_IGNORE="$no_ignore"
  export BZB_REVERSE="$reverse"

  # Edit file or enter directory
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
    # clear query after changing directory
    export BZB_QUERY=''
  elif [[ $# -ge 1 ]]; then
    edit="${EDITOR:vi}"
    for f in "$@"; do
      edit="$edit '$f'"
    done
    [[ ! $no_edit ]] && bash -c "$edit"
    [[ ! $persist ]] && exit 0
  fi

  # Setup list/sort/preview commands
  if [[ $grep_mode ]]; then
    export BZB_GREP_QUERY="$grep_query"
    [[ $shallow ]] && grep="$grep_shallow" || grep="$grep_recursive"
    preview_opts="--preview='$grep_mode_preview' --preview-window='$preview_window'"
    fzf_input=$(bash -c "echo \"$grep\"")
    fzf_prompt="/$grep_query/"
  else
    [[ $shallow ]] && find="$find_shallow" || find="$find_recursive"
    preview_opts="--preview='$find_mode_preview' --preview-window='$preview_window'"
    fzf_input=$(bash -c "echo \"$find\${sorted:+ | $sort}\"")
    fzf_prompt="${PWD#$base_dir}>"
  fi
  [[ ! $preview ]] && preview_opts=''

  # Clear leading dots from paths
  fzf_input+=" | sed 's:^\./::'"

  fzf_options="${no_clear:+--no-clear} --print-query --multi --layout='reverse' --bind=alt-k:up,alt-j:down,ctrl-g:ignore,esc:cancel --expect='$fzf_keys' --query='$BZB_QUERY' --prompt='$fzf_prompt' $preview_opts ${fzf_opts[@]}"

  # CYCLE INTO FZF
  fzf_command="$fzf_input | fzf $fzf_options"
  { read query; read command; readarray -t targets; } < <(bash -c "$fzf_command")

  # Parse empty command and empty target as 'exit' (fzf-native 'escape' or 'ctrl-c' mapping)
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  # Parse empty command as 'enter' action
  [[ -z "$command" ]] && command='right'

  if [[ $no_edit && "$command" = 'right' ]]; then
    selection="${data_dir:+$data_dir/selection.bzb}"
    if [[ -n "$selection" ]]; then
      save_selection
    fi
  fi

  action="${key_actions[$command]}"

  next_targets=()
  case $action in
    # Use alt-/ to enter grep mode using search pattern specified at prompt
    # Use again to update search pattern. Enter empty pattern to cancel
    grep)
      clear && read -ep "Grep for Pattern: " -i "$grep_query" grep_query
      [[ $grep_query ]] && grep_mode=1 || grep_mode=''
    ;;

    # Use left arrow to move up a directory, but not above base directory
    # If in grep mode, exit and resume browsing current directory
    back|back2)
      if [[ ! $grep_mode && "$PWD" != "$base_dir" ]]; then
        next_targets=("..")
      else
        next_targets=('.')
        grep_mode=''
      fi
    ;;

    # Exit grep-mode if any other directory navigation is used
    next-bookmark|next-bookmark2|prev-bookmark|prev-bookmark2|select-bookmark|select-bookmark2|select-nested-bookmark|select-nested-bookmark2|enter-base-dir|prompt-dir|set-base-dir|enter-alt-dir|enter-prev-dir)
      grep_mode=''
    # Fall through to remaining cases
    ;;&

    # Use ctrl-g to toggle in/out of grep mode (not changing search pattern)
    grep2)
      [[ $grep_mode ]] && grep_mode='' || grep_mode=1
    ;;

    # Use alt-n to toggle listing nested vs only top-level files/directories
    toggle-nested)
      [[ $shallow ]] && shallow='' || shallow=1
    ;;

    # Use alt-i to toggle visibility of ignored files/directories
    toggle-ignored)
      [[ $no_ignore ]] && no_ignore='' || no_ignore=1
    ;;

    # Use alt-v to toggle visibility of hidden files/directories
    toggle-hidden)
      [[ $hidden ]] && hidden='' || hidden=1
    ;;

    # Use ctrl-alt-p to toggle visibility of preview pane
    toggle-preview)
      [[ $preview ]] && preview='' || preview=1
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    toggle-sort-order)
      [[ $reverse ]] && reverse='' || reverse=1
    ;;

    # Use ctrl-alt-s to enable/disable sorting
    toggle-sort)
      [[ $sorted ]] && sorted='' || sorted=1
    ;;

    # Use alt-q to quick-launch targets in their native client
    launch)
      if [[ "$launch" ]]; then
        for t in "${targets[@]}"; do
          bash -c "$launch '$t'"
        done
      fi
    ;;

    # Use alt-r to rename targets in current directory
    rename)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          clear && read -ep 'Move/Rename File: ' -i "mv \"$t\" \"$t\"" cmd
          [[ -n "$cmd" ]] && bash -c "$cmd"
        fi
      done
    ;;

    # Use alt-m to move targets
    move)
      clear && read -ep 'Move to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && mv -i "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-r or ctrl-alt-m to move and rename targets
    move-rename|move-rename2)
      clear && read -ep 'Move/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Move/Rename File: ' -i "mv '$PWD/$t' '${dir%/}/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-x to delete targets
    delete)
      CMD="$rm_interactive"
      for t in "${targets[@]}"; do
        CMD="$CMD '$t'"
      done
      clear && bash -c "$CMD"
    ;;

    # Use alt-c to copy targets
    copy)
      clear && read -ep 'Copy to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && cp -ir "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-c to copy and rename targets
    copy-rename)
      clear && read -ep 'Copy/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            clear && read -ep 'Copy/Rename File: ' -i "cp -ir '$PWD/$t' '$dir/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-d to create directory named at prompt
    # Use ctrl-alt-d to create directory and enter it
    create-dir|create-enter-dir)
      clear && read -p "Create directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = "${action_keys[create-enter-dir]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-f to create file named at prompt
    # Use alt-e to create file and edit it immediately
    create-file|create-edit-file)
      clear && read -p "Create file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = "${action_keys[create-edit-file]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to bookmark selected targets
    bookmark-targets)
      dir="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$dir/$b" ]]; then
          cd "$dir/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$dir"
    ;;

    # Use ctrl-alt-b to bookmark current directory
    bookmark-current-dir)
      [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
    ;;

    # Use alt-u to select bookmarks to delete
    unbookmark-dirs)
      current_dir="$PWD"
      readarray -t dirs < <(dirs -p -l)
      bookmarks=("$(printf '%s\n' "${dirs[@]}" | LC_ALL=C sort -u | fzf --multi --bind=alt-k:up,alt-j:down,ctrl-g:unix-line-discard+print-query,esc:unix-line-discard+print-query --prompt='[unbookmark]')")
      for b in ${bookmarks[@]}; do
        for i in "${!dirs[@]}"; do
          if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$b" ]]; then
            popd -n +$i >/dev/null
          fi
        done
      done
      cd "$current_dir"
    ;;

    # Use ctrl-alt-u to unbookmark current directory
    unbookmark-current-dir)
      for i in "${!dirs[@]}"; do
        if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$PWD" ]]; then
          popd +$i >/dev/null
        fi
      done
      pushd +1 >/dev/null 
    ;;

    # Use alt-right or ctrl-alt-l to go to next bookmarked directory
    next-bookmark|next-bookmark2)
      cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      fi
    ;;

    # Use alt-left or ctrl-alt-h to go to previous bookmarked directory
    prev-bookmark|prev-bookmark2)
      cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      fi
    ;;

    # Use alt-up or ctrl-alt-k to select bookmarked directory using fzf
    select-bookmark|select-bookmark2)
      readarray -t dirs < <(dirs -p -l | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf --bind=alt-k:up,alt-j:down,ctrl-g:unix-line-discard+print-query,esc:unix-line-discard+print-query --prompt='[go to directory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-down or ctrl-alt-j to select bookmarked directory under current directory
    select-nested-bookmark|select-nested-bookmark2)
      readarray -t dirs < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf --bind=alt-k:up,alt-j:down,ctrl-g:unix-line-discard+print-query,esc:unix-line-discard+print-query --prompt='[go to subdirectory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-p to go to previous directory
    enter-prev-dir)
      cd "$OLDPWD"
    ;;

    # Use alt-g to go to directory named at prompt
    prompt-dir)
      clear && read -ep "Go to directory: " -i "$PWD" dir
      [[ -d "$dir" ]] && cd "$dir" || echo "Not a directory"
    ;;

    # Use alt-a to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    # Use alt-s to set alternate directory
    set-alt-dir|enter-alt-dir)
      if [[ "$action" = "set-alt-dir" || ! -d "$alt_dir" ]]; then
        clear && read -ep "Set alternate directory: " -i "$PWD" dir
        [[ -d "$dir" ]] && alt_dir="${dir%/}" || echo "Not a directory"
      fi
      if [[ "$action" = "enter-alt-dir" && -d "$alt_dir" ]]; then
        [[ "$PWD" = "$alt_dir" ]] && cd "$OLDPWD" || cd "$alt_dir"
      fi
    ;;

    # Use ctrl-alt-g to set/enter new base directory
    # Use alt-z to go to base directory, or go back
    # to previous directory if already in base directory
    # Use alt-y to load session
    set-base-dir|enter-base-dir|load-session)
      if [[ "$action" = "set-base-dir" || ! -d "$base_dir" ]]; then
        clear && read -ep "Set base directory: " -i "$PWD" dir
        if [[ -d "$dir" ]]; then
          base_dir="${dir%/}"
          pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
          [[ ! "$autoload_session" ]] && action="load-session"
        elif [[ -n "$dir" ]]; then
          echo "Not a directory"
        fi
      fi
      if [[ -d "$base_dir" ]]; then
        [[ "$PWD" = "$base_dir" ]] && cd "$OLDPWD" || cd "$base_dir"
      fi
      if [[ "$action" = 'load-session' ]]; then
        session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
        clear && read -ep "Load session: " -i "$session" session
        if [[ -r "$session" ]]; then
          . -- "$session"
          load_session
        fi
      fi
    ;;

    # Use ctrl-alt-y to save session
    save-session)
      session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
      clear && read -ep "Save session: " -i "$session" session
      if [[ -n "$session" ]]; then
        save_session
      fi
    ;;

    # Use ctrl-alt-n to restore normal view/sort settings
    reset-view)
      shallow=1
      hidden=''
      no_ignore=''
      sorted=1
      reverse=''
      preview=1
    ;;

    # Use enter or right arrow to edit file or enter directory
    enter|enter2)
      next_targets=("${targets[@]}")
    ;;
  esac

  if [[ "$autosave_session" ]]; then
    session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
    if [[ -n "$session" ]]; then
      save_session
    fi
  fi

  main "${next_targets[@]}"
}

# Default initial target is current directory
main "${initial_target:-$base_dir}"
