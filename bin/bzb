#!/bin/bash
set -e

function finish() {
  # Leave alternate screen manually on exit due to fzf '--no-clear' option
  [[ $no_clear ]] && tput rmcup
}
trap finish EXIT

function hasCmd() {
  command -v "$1" &>/dev/null
}

hasCmd tput && no_clear=1

# Find Commands: Prefer 'fd' over 'find' so ignored files are not listed
if hasCmd fd; then
  find_recursive="fd \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
  find_shallow="fd --max-depth 1 \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
else
  find_recursive="find . -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
  find_shallow="find . -maxdepth 1 -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
fi

# Sort Command:
sort="LC_ALL=C sort \${BZB_REVERSE:+-r} -fiu"

# Preview Commands:
preview_directory="ls \${BZB_COLOR:+--color=always} \${BZB_HIDDEN:+-a} -lh {}"
preview_text="cat {}"
is_binary='test `head -qc 8192 {} 2>/dev/null | grep -o "[^[:print:]]" 2>/dev/null | wc -c` -gt 16'
if hasCmd file; then
  preview_binary="file -L {}"
  is_binary='[[ ! "$(file -L {})" =~ 'text' ]] && '"$is_binary"
else
  preview_binary="stat -L {}"
fi

preview_file="( $is_binary && $preview_binary || $preview_text )"
find_preview="[[ -d {} ]] && $preview_directory || $preview_file"

# Grep Commands: Prefer 'rg' over 'grep' so ignored files are not listed
if hasCmd rg; then
  grep_recursive="rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  grep_shallow="rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --max-depth 1 --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  grep_preview="rg \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --ignore-case --no-messages --context 1 '\${BZB_GREP_QUERY}' '{}'"
else
  # TODO: Support ignoring hidden files recursively
  grep_recursive="grep -r -l -i -s -C 1 '\${BZB_GREP_QUERY}' ."
  grep_shallow="grep -l -i -s -C 1 '\${BZB_GREP_QUERY}' "'$([[ $BZB_HIDDEN ]] && echo "*" || echo "{*,.*}")'
  grep_preview="grep \${BZB_COLOR:+--color=always} -i -s -C 1 '\${BZB_GREP_QUERY}' {}"
fi

# Quick-launch Command: Used to open targets in their native client
launch=''
hasCmd xdg-open && launch='xdg-open'
hasCmd open && launch='open'

# Prefer -I option to -i for removing files, if available
rm -I '' 2>&1 | grep '\(unrecognized\|invalid\) option' &>/dev/null && rm_interactive='rm -ri' || rm_interactive='rm -rI'

# Directory where data for loading/restoring sessions is saved (optional)
BZB_DIR="$HOME/.bzb"

# Launch editor as the enter-action for files. Enabling this option wil only log selected targets
# to a 'selection' file in BZB_DIR.  (Useful when integrating/launching bzb from an editor instead.)
# Enabling implies 'persist' option below is false
no_edit=''

# Stay in browser after editing files
persist=1

# Start with only top-level files/directories displayed
shallow=1

# No color output
color=''

# Don't show hidden files
hidden=''

# Don't show ignored files
no_ignore=''

# Don't start in grep mode
grep_mode=''

# Sort ascending
sorted=1
reverse=''

# Display preview pane
preview=1
preview_window='right:62%:wrap'

# Save/Load sessions manually
autosave_session=''
autoload_session=''

declare -A key_definitions key_actions action_keys
declareKeymap() {
  keys[${#keys[@]}]="$2"
  key_definitions["$2"]="$3"
  key_actions["$2"]="$1"
  action_keys["$1"]="$2"
}

declareKeymap 'enter'                   'right'       "enter directory or edit file"
declareKeymap 'back'                    'left'        "go to parent directory (not moving past base directory)"
declareKeymap 'launch'                  'alt-q'       "quick-launch targets using native client"
declareKeymap 'grep'                    'alt-/'       "grep for pattern specified at prompt ('left' will exit grep mode)"
declareKeymap 'move'                    'alt-m'       "move targets to directory named at prompt"
declareKeymap 'rename'                  'alt-r'       "rename targets in current directory"
declareKeymap 'move-rename'             'ctrl-alt-m'  "move/rename targets into directory named at prompt"
declareKeymap 'move-rename2'            'ctrl-alt-r'  "move/rename targets into directory named at prompt"
declareKeymap 'delete'                  'alt-x'       "delete targets"
declareKeymap 'copy'                    'alt-c'       "copy targets to directory named at prompt"
declareKeymap 'copy-rename'             'ctrl-alt-c'  "copy/rename targets into directory named at prompt"
declareKeymap 'create-edit-file'        'alt-e'       "create/edit file named at prompt"
declareKeymap 'create-file'             'alt-f'       "create file without editing"
declareKeymap 'create-dir'              'alt-d'       "create directory named at prompt"
declareKeymap 'create-enter-dir'        'ctrl-alt-d'  "create/enter directory named at prompt"
declareKeymap 'bookmark-targets'        'alt-b'       "bookmark target directories"
declareKeymap 'bookmark-current-dir'    'ctrl-alt-b'  "bookmark current directory"
declareKeymap 'unbookmark-dirs'         'alt-u'       "unbookmark selected directories"
declareKeymap 'unbookmark-current-dir'  'ctrl-alt-u'  "unbookmark current directory"
declareKeymap 'next-bookmark'           'alt-right'   "go to next bookmarked directory"
declareKeymap 'next-bookmark2'          'alt-l'       "go to next bookmarked directory"
declareKeymap 'prev-bookmark'           'alt-left'    "go to previous bookmarked directory"
declareKeymap 'prev-bookmark2'          'alt-h'       "go to previous bookmarked directory"
declareKeymap 'select-bookmark'         'alt-up'      "select and enter bookmarked directory"
declareKeymap 'select-bookmark2'        'alt-k'       "select and enter bookmarked directory"
declareKeymap 'select-nested-bookmark'  'alt-down'    "select and enter bookmarked directory under current directory"
declareKeymap 'select-nested-bookmark2' 'alt-j'       "select and enter bookmarked directory under current directory"
declareKeymap 'set-alt-dir'             'alt-s'       "set alternate directory (default for copy/move prompts)"
declareKeymap 'enter-alt-dir'           'alt-a'       "switch between current and alternate directory"
declareKeymap 'enter-base-dir'          'alt-z'       "switch between current and base directory"
declareKeymap 'enter-prev-dir'          'alt-p'       "switch between current and previous directory"
declareKeymap 'prompt-dir'              'alt-g'       "go to directory named at prompt"
declareKeymap 'set-base-dir'            'ctrl-alt-g'  "set new base directory at prompt and go to it"
declareKeymap 'toggle-preview'          'ctrl-alt-p'  "toggle visibility of preview pane"
declareKeymap 'toggle-ignored'          'alt-i'       "toggle visibility of ignored files (if supported)"
declareKeymap 'toggle-hidden'           'alt-v'       "toggle visibility of hidden files"
declareKeymap 'toggle-nested'           'alt-n'       "toggle listing nested vs. only top-level files"
declareKeymap 'toggle-sort-order'       'alt-o'       "toggle sort order ascending/descending"
declareKeymap 'toggle-sort'             'ctrl-alt-s'  "toggle sorted/unsorted results (affects performance)"
declareKeymap 'reset-view'              'ctrl-alt-n'  "restore normal view settings (nested/hidden/ignored)"
declareKeymap 'load-session'            'alt-y'       "load session from file named at prompt"
declareKeymap 'save-session'            'ctrl-alt-y'  "save session to file named at prompt"

# comma-separated list of custom mappings for fzf
fzf_keys="$(printf ",%s" "${keys[@]}" | cut -c2-)"

usage() {
cat <<USAGE
usage: $(basename "${BASH_SOURCE[0]}") [options] [target file or directory]

Browse files using fzf. If no target specified start in the current directory.

Key mappings:

$(awk -F ':' '{ printf("%-12s %-66s %s\n", $1, $2, $3) }' <(
cat <<KEY_USAGE
KEYMAP:DESCRIPTION:ACTION_NAME
escape:exit file browser
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${keys[@]}"; do echo "$k:${key_definitions[$k]}:${key_actions[$k]}"; done)
KEY_USAGE
))

Options:

--help,-h                          Show this help text
--grep,-g                          Start in grep mode
--once,-o                          Exit browser after editing a file
--color,-c                         Show colorized output
--recursive,-r                     Show nested files/direcories at start
--hidden,-H                        Show hidden files/direcories at start
--no-ignore,-I                     Show ignored files/direcories at start
--no-preview,-P                    Disable preview pane that shows file/directory contents
--no-sort,-S                       Disable sorting of files/directories
--no-edit,-E                       Disable launch of editor and just log selection to file
--reverse-sort,-R                  Reverse the normal sort order
--auto-save-session,-s             Save bookmarks and view/sort settings continuously
--auto-load-session,-l             Load bookmarks and view/sort settings at start
--sort=CMD,-so=CMD                 Command to sort files/directories
--find-shallow=CMD,-sf=CMD         Command to list only top-level files/directories
--find-recursive=CMD,-rf=CMD       Command to list nested files/directories
--file-preview=CMD,-fp=CMD         Command to preview currently focused file
--directory-preview=CMD,-dp=CMD    Command to preview currently focused directory
--grep-shallow=CMD,-sg=CMD         Command to grep for pattern in top-level files/directories
--grep-recursive=CMD,-rg=CMD       Command to grep for pattern recursively
--grep-preview=CMD,-gp=CMD         Command to preview grep results for currently focused file
--quick-launch=CMD,-ql=CMD         Command to launch files/directories using os-native client
--base-directory=DIR,-bd=DIR       Specify a base directory instead of deriving it from target
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start

Any additional options will be passed to fzf.
USAGE
}

for arg in "$@"; do
  case $arg in
    -h|--help) usage; exit 0 ;;
    -g|--grep) grep_mode=''; shift ;;
    -o|--once) persist=''; shift ;;
    -c|--color) color=1; shift ;;
    -r|--recursive) shallow=''; shift ;;
    -H|--hidden) hidden=1; shift ;;
    -I|--no-ignore) no_ignore=1; shift ;;
    -P|--no-preview) preview=''; shift ;;
    -S|--no-sort) sorted=''; shift ;;
    -E|--no-edit) no_edit=1; persist=''; shift ;;
    -R|--reverse-sort) reverse=1; shift ;;
    -s|--auto-save-session) autosave_session=1; shift ;;
    -l|--auto-load-session) autoload_session=1; shift ;;
    -so=*|--sort=*) sort="${arg#*=}"; shift ;;
    -sf=*|--find-shallow=*) find_shallow="${arg#*=}"; shift ;;
    -rf=*|--find-recursive=*) find_recursive="${arg#*=}"; shift ;;
    -fp=*|--file-preview=*) preview_file="${arg#*=}"; shift ;;
    -dp=*|--directory-preview=*) preview_directory="${arg#*=}"; shift ;;
    -sg=*|--grep-shallow=*) grep_shallow="${arg#*=}"; shift ;;
    -rg=*|--grep-recursive=*) grep_recursive="${arg#*=}"; shift ;;
    -gp=*|--grep-preview=*) grep_preview="${arg#*=}"; shift ;;
    -ql=*|--quick-launch=*) launch="${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) base_dir="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) alt_dir="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    # TODO: Capture non '=' style arguments 
    -*) fzf_opts+=("${arg%%=*}=\"${arg#*=}\""); shift ;;
  esac
done

initial_target="$1"

# Derive base directory from target, or use current directory if none given
if [[ -z "$base_dir" ]]; then
  [[ -d "$initial_target" ]] && base_dir="$initial_target" || base_dir="$(dirname "${initial_target:-$PWD/.}")"
fi
pushd "$base_dir" >/dev/null && pushd +1 >/dev/null

function save_selection() {
  mkdir -p "$(dirname $selection)" && touch "$selection"
  if [[ -w "$selection" ]]; then
    > "$selection"
    for t in "${targets[@]}"; do
      if [[ -r "$t" ]]; then
        echo "$PWD/$t" >> "$selection"
      fi
    done
  fi
}

function save_session() {
  mkdir -p "$(dirname $session)" && touch "$session"
  readarray -t bookmarks < <(dirs -p -l)
  if [[ -w "$session" ]]; then
    declare -p PWD > "$session"
    [[ "$base_dir" ]] && declare -p base_dir >> "$session"
    [[ "$alt_dir" ]] && declare -p alt_dir >> "$session"
    declare -p bookmarks >> "$session"
    declare -p shallow >> "$session"
    declare -p hidden >> "$session"
    declare -p no_ignore >> "$session"
    declare -p sorted >> "$session"
    declare -p reverse >> "$session"
    declare -p preview >> "$session"
  fi
}

function load_session() {
  dirs -c
  pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
  for b in "${bookmarks[@]}"; do
    [[ -d "$b" ]] && pushd "$b" >/dev/null
  done
  cd "$base_dir"
}

if [[ "$autoload_session" ]]; then
  session="${BZB_DIR:+$BZB_DIR/sessions$base_dir/session.bzb}"
  if [[ -r "$session" ]]; then
    . -- "$session"
    load_session;
  fi
fi

main() {
  # Export variables for use in subshells
  export BZB_QUERY="$query"
  export BZB_COLOR="$color"
  export BZB_HIDDEN="$hidden"
  export BZB_NO_IGNORE="$no_ignore"
  export BZB_REVERSE="$reverse"

  # Edit file or enter directory
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
    # clear query after changing directory
    export BZB_QUERY=''
  elif [[ $# -ge 1 ]]; then
    edit="${EDITOR:vi}"
    for f in "$@"; do
      edit="$edit '$f'"
    done
    [[ ! $no_edit ]] && bash -c "$edit"
    [[ ! $persist ]] && exit 0
  fi

  # Setup list/sort/preview commands
  if [[ $grep_mode ]]; then
    export BZB_GREP_QUERY="$grep_query"
    [[ $shallow ]] && grep="$grep_shallow" || grep="$grep_recursive"
    preview_opts="--preview='$grep_preview' --preview-window='$preview_window'"
    fzf_input=$(bash -c "echo \"$grep\"")
    fzf_prompt="/$grep_query/"
  else
    [[ $shallow ]] && find="$find_shallow" || find="$find_recursive"
    preview_opts="--preview='$find_preview' --preview-window='$preview_window'"
    fzf_input=$(bash -c "echo \"$find\${sorted:+ | $sort}\"")
    fzf_prompt="${PWD#$base_dir}>"
  fi
  [[ ! $preview ]] && preview_opts=''

  # Clear dots from paths
  fzf_input+=" | sed 's:^\./::'"

  fzf_options="${no_clear:+--no-clear} --print-query --multi --layout='reverse' --expect='$fzf_keys' --query='$BZB_QUERY' --prompt='$fzf_prompt' $preview_opts ${fzf_opts[@]}"

  fzf_cmd="$fzf_input | fzf $fzf_options"

  # CYCLE INTO FZF
  { read query; read command; readarray -t targets; } < <(bash -c "$fzf_cmd")

  # Parse empty command and empty target as 'exit' (fzf-native 'escape' or 'ctrl-c' mapping)
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  # Parse empty command as 'enter' action
  [[ -z "$command" ]] && command='right'

  if [[ $no_edit && "$command" = 'right' ]]; then
    selection="${BZB_DIR:+$BZB_DIR/selection.bzb}"
    if [[ -n "$selection" ]]; then
      save_selection
    fi
  fi

  action="${key_actions[$command]}"

  next_targets=()
  case $action in
    # Use alt-/ to enter grep mode using search pattern specified at prompt
    # Use again to update search pattern. Enter empty pattern to cancel
    grep)
      clear && read -ep "Grep for Pattern: " -i "$grep_query" grep_query
      [[ $grep_query ]] && grep_mode=1 || grep_mode=''
    ;;

    # Use left arrow to move up a directory, but not above base directory
    # If in grep mode, exit and resume browsing current directory
    back)
      if [[ ! $grep_mode && "$PWD" != "$base_dir" ]]; then
        next_targets=("..")
      else
        next_targets=('.')
        grep_mode=''
      fi
    ;;

    # Exit grep-mode if any other directory navigation is used
    next-bookmark|next-bookmark2|prev-bookmark|prev-bookmark2|select-bookmark|select-bookmark2|select-nested-bookmark|select-nested-bookmark2|enter-base-dir|prompt-dir|set-base-dir|enter-alt-dir|enter-prev-dir)
      grep_mode=''
    # Fall through to remaining cases
    ;;&

    # Use alt-n to toggle listing nested vs only top-level files/directories
    toggle-nested)
      [[ $shallow ]] && shallow='' || shallow=1
    ;;

    # Use alt-i to toggle visibility of ignored files/directories
    toggle-ignored)
      [[ $no_ignore ]] && no_ignore='' || no_ignore=1
    ;;

    # Use alt-v to toggle visibility of hidden files/directories
    toggle-hidden)
      [[ $hidden ]] && hidden='' || hidden=1
    ;;

    # Use ctrl-alt-p to toggle visibility of preview pane
    toggle-preview)
      [[ $preview ]] && preview='' || preview=1
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    toggle-sort-order)
      [[ $reverse ]] && reverse='' || reverse=1
    ;;

    # Use ctrl-alt-o to enable/disable sorting
    toggle-sort)
      [[ $sorted ]] && sorted='' || sorted=1
    ;;

    # Use alt-q to quick-launch targets in their native client
    launch)
      if [[ "$launch" ]]; then
        for t in "${targets[@]}"; do
          bash -c "$launch '$t'"
        done
      fi
    ;;

    # Use alt-r to rename targets in current directory
    rename)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          clear && read -ep 'Move/Rename File: ' -i "mv \"$t\" \"$t\"" cmd
          [[ -n "$cmd" ]] && bash -c "$cmd"
        fi
      done
    ;;

    # Use ctrl-alt-r to move and rename targets
    move-rename|move-rename2)
      clear && read -ep 'Move/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Move/Rename File: ' -i "mv '$PWD/$t' '${dir%/}/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-m to move targets
    move)
      clear && read -ep 'Move to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && mv -i "${targets[@]}" "$dir"
    ;;

    # Use alt-x to delete targets
    delete)
      CMD="$rm_interactive"
      for t in "${targets[@]}"; do
        CMD="$CMD '$t'"
      done
      clear && bash -c "$CMD"
    ;;

    # Use alt-c to copy targets
    copy)
      clear && read -ep 'Copy to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && cp -ir "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-c to copy and rename targets
    copy-rename)
      clear && read -ep 'Copy/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            clear && read -ep 'Copy/Rename File: ' -i "cp -ir '$PWD/$t' '$dir/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-d to create directory named at prompt
    # Use ctrl-alt-d to create directory and enter it
    create-dir|create-enter-dir)
      clear && read -p "Create directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = "${action_keys[create-enter-dir]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-f to create file named at prompt
    # Use alt-e to create file and edit it immediately
    create-file|create-edit-file)
      clear && read -p "Create file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = "${action_keys[create-edit-file]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to bookmark selected targets
    bookmark-targets)
      dir="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$dir/$b" ]]; then
          cd "$dir/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$dir"
    ;;

    # Use ctrl-alt-b to bookmark current directory
    bookmark-current-dir)
      [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
    ;;

    # Use alt-u to select bookmarks to delete
    unbookmark-dirs)
      current_dir="$PWD"
      readarray -t dirs < <(dirs -p -l)
      bookmarks=("$(printf '%s\n' "${dirs[@]}" | LC_ALL=C sort -u | fzf --multi)")
      for b in ${bookmarks[@]}; do
        for i in "${!dirs[@]}"; do
          if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$b" ]]; then
            popd -n +$i >/dev/null
          fi
        done
      done
      cd "$current_dir"
    ;;

    # Use ctrl-alt-u to unbookmark current directory
    unbookmark-current-dir)
      for i in "${!dirs[@]}"; do
        if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$PWD" ]]; then
          popd +$i >/dev/null
        fi
      done
      pushd +1 >/dev/null 
    ;;

    # Use alt-right or alt-l to go to next bookmarked directory
    next-bookmark|next-bookmark2)
      cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      fi
    ;;

    # Use alt-left or alt-h to go to previous bookmarked directory
    prev-bookmark|prev-bookmark2)
      cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      fi
    ;;

    # Use alt-up or alt-k to select bookmarked directory using fzf
    select-bookmark|select-bookmark2)
      readarray -t dirs < <(dirs -p -l | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf)")
    ;;

    # Use alt-down or alt-j to select bookmarked directory under current directory
    select-nested-bookmark|select-nested-bookmark2)
      readarray -t dirs < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf)")
    ;;

    # Use alt-p to go to previous directory
    enter-prev-dir)
      cd "$OLDPWD"
    ;;

    # Use alt-g to go to directory named at prompt
    prompt-dir)
      clear && read -ep "Go to directory: " -i "$PWD" dir
      [[ -d "$dir" ]] && cd "$dir" || echo "Not a directory"
    ;;

    # Use alt-a to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    # Use alt-s to set alternate directory
    set-alt-dir|enter-alt-dir)
      if [[ "$action" = "set-alt-dir" || ! -d "$alt_dir" ]]; then
        clear && read -ep "Set alternate directory: " -i "$PWD" dir
        [[ -d "$dir" ]] && alt_dir="${dir%/}" || echo "Not a directory"
      fi
      if [[ "$action" = "enter-alt-dir" && -d "$alt_dir" ]]; then
        [[ "$PWD" = "$alt_dir" ]] && cd "$OLDPWD" || cd "$alt_dir"
      fi
    ;;

    # Use ctrl-alt-g to set/enter new base directory
    # Use alt-u to go to base directory, or go back
    # to previous directory if already in base directory
    # Use alt-y to load session
    set-base-dir|enter-base-dir|load-session)
      if [[ "$action" = "set-base-dir" || ! -d "$base_dir" ]]; then
        clear && read -ep "Set base directory: " -i "$PWD" dir
        if [[ -d "$dir" ]]; then
          base_dir="${dir%/}"
          pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
          [[ ! "$autoload_session" ]] && action="load-session"
        else
          echo "Not a directory"
        fi
      fi
      if [[ -d "$base_dir" ]]; then
        [[ "$PWD" = "$base_dir" ]] && cd "$OLDPWD" || cd "$base_dir"
      fi
      if [[ "$action" = 'load-session' ]]; then
        session="${BZB_DIR:+$BZB_DIR/sessions$base_dir/session.bzb}"
        clear && read -ep "Load session: " -i "$session" session
        if [[ -r "$session" ]]; then
          . -- "$session"
          load_session
        fi
      fi
    ;;

    # Use ctrl-alt-y to save session
    save-session)
      session="${BZB_DIR:+$BZB_DIR/sessions$base_dir/session.bzb}"
      clear && read -ep "Save session: " -i "$session" session
      if [[ -n "$session" ]]; then
        save_session
      fi
    ;;

    # Use ctrl-alt-n to restore normal view/sort settings
    reset-view)
      shallow=1
      hidden=''
      no_ignore=''
      sorted=1
      reverse=''
      preview=1
    ;;

    # Use enter or right arrow to edit file or enter directory
    enter)
      next_targets=("${targets[@]}")
    ;;
  esac

  if [[ "$autosave_session" ]]; then
    session="${BZB_DIR:+$BZB_DIR/sessions$base_dir/session.bzb}"
    if [[ -n "$session" ]]; then
      save_session
    fi
  fi

  main "${next_targets[@]}"
}

# Default initial target is current directory
main "${initial_target:-$base_dir}"
