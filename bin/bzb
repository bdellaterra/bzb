#!/bin/bash
set -e

if [[ "${BASH_VERSINFO[0]}" -lt 2 ]]; then
  echo "Error: $(basename "${BASH_SOURCE[0]}") requires a newer version of bash" 1>&2
  exit 1
fi

# Test if command exists
has() {
  command -v "$1" &>/dev/null
}

# In the variable name provided as first argument, store the default value provided
# as second argument. If BZB_ prefixed all-caps variable is defined use its value instead
init() {
  override="BZB_${1^^}"
  [[ -n "${!override+defined}" ]] && value="${!override}" || value="$2"
  # Avoid polluting global namespace if bash supports namerefs (version 4.3+)
  if [[ "${BASH_VERSINFO[0]}" -ge 4 && "${BASH_VERSINFO[0]}" -ge 3 ]]; then
    local -n outvar="$1"
    outvar="$value"
  else
    export "$1=$value"
  fi
}

# Leave alternate screen manually on exit after using fzf '--no-clear' option
clear_fzf() {
  [[ $fzf_command && $no_clear ]] && tput rmcup
}

# Detect terminal/color-support and exit if not interactive
if [[ -t 0 || -p /dev/stdin ]]; then
  init 'color' ''
  if has tput; then
    declare -r no_clear=1
    trap clear_fzf EXIT
    test $(tput colors) -ge 8 && init 'color' 1
  fi
else
  echo "Error: $(basename "${BASH_SOURCE[0]}") must be run interactively" 1>&2
  exit 1
fi

# Additional options to be passed to fzf
# TODO: support array initialization
init 'fzf_extra_options' ''

# Directory where data for loading/restoring sessions is saved (optional)
init 'data_dir' "$HOME/.bzb" && readonly data_dir

# Default behavior is to launch $EDITOR as the enter-action for files. Enabling option below
# will instead only log selected targets to a 'selection' file in data_dir. This communicates
# user-actions to another program that has launched bzb as an integrated file browser.
# Enabling this option will set 'persist' option below to false
init 'no_edit' ''

# Stay in browser after editing files
init 'persist' 1

# Start with only top-level files/directories displayed
init 'shallow' 1

# Don't show hidden files
init 'hidden' ''

# Don't show ignored files
init 'no_ignore' ''

# Don't start in grep mode
init 'grep_mode' ''

# Sort ascending
init 'sorted' 1
init 'reverse' ''

# Display preview pane
init 'preview' 1
init 'preview_window' 'right:62%:wrap'

# Display status of toggle settings above results listing
init 'toggle_status' 1

# Save/Load sessions manually
init 'autosave_session' ''
init 'autoload_session' ''

# Find Commands: Prefer 'fd' over 'find' so ignored files are not listed
if has fd; then
  init 'find_recursive' \
    "fd \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
  init 'find_shallow' \
    "fd --max-depth 1 \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
else
  init 'find_recursive' \
    "find . -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
  init 'find_shallow' \
    "find . -maxdepth 1 -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
fi

# Sort Command:
init 'sort' \
  "LC_ALL=C sort \${BZB_REVERSE:+-r} -fiu"

# Preview Commands:
init 'preview_directory' \
  "ls \${BZB_COLOR:+--color=always} \${BZB_HIDDEN:+-a} -lh {}"
init 'preview_text' \
  "cat {}"
init 'is_binary' \
  'test `head -qc 8192 {} 2>/dev/null | grep -o "[^[:print:]]" 2>/dev/null | wc -c` -gt 16'

if has file; then
  init 'preview_binary' \
    "file -L {}"
  init 'is_binary' \
    '[[ ! "$(file -L {})" =~ 'text' ]] && '"$is_binary"
else
  init 'preview_binary' \
    "stat -L {}"
fi

init 'preview_file' \
  "( $is_binary && $preview_binary || $preview_text )"
init 'find_mode_preview' \
  "[[ -d {} ]] && $preview_directory || $preview_file"

# Grep Commands: Prefer 'rg' over 'grep' so ignored files are not listed
if has rg; then
  init 'grep_recursive' \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  init 'grep_shallow' \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --max-depth 1 --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  init 'grep_mode_preview' \
    "rg \${BZB_COLOR:+--color} \${BZB_COLOR:+always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --ignore-case --no-messages --context 1 '\${BZB_GREP_QUERY}' '{}'"
else
  # TODO: Support ignoring hidden files recursively
  init 'grep_recursive' \
    "grep -r -l -i -s -C 1 '\${BZB_GREP_QUERY}' ."
  init 'grep_shallow' \
    "grep -l -i -s -C 1 '\${BZB_GREP_QUERY}' "'$([[ $BZB_HIDDEN ]] && echo "*" || echo "{*,.*}")'
  init 'grep_mode_preview' \
    "grep \${BZB_COLOR:+--color=always} -i -s -C 1 '\${BZB_GREP_QUERY}' {}"
fi

# Quick-launch Command: Used to open targets in their native client
init 'launch' ''
has xdg-open && init 'launch' 'xdg-open'
has open && init 'launch' 'open'

# Prefer -I option to -i for removing files, if available
rm -I '' 2>&1 | grep '\(unrecognized\|invalid\) option' &>/dev/null && \
  init 'rm_interactive' 'rm -ri' || rm_interactive='rm -rI'


# Set readline keybinds for cancelling prompts with ctr-g or double-escape
# Binding single-escape could cause side effects due to its use as a common meta character
bind '"\C-g":"\C-k\C-u
"' '"\e\e":"\C-g"' &>/dev/null

# Set fzf keybinds for movement and exit actions
init 'fzf_bind' '--bind=alt-k:up,alt-j:down,ctrl-g:ignore,esc:cancel'
init 'fzf_submenu_bind' '--bind=alt-k:up,alt-j:down,ctrl-g:unix-line-discard+print-query,esc:unix-line-discard+print-query'

declare -A key_definitions key_actions action_keys
map() {
  keys[${#keys[@]}]="$2"
  key_definitions["$2"]="$3"
  key_actions["$2"]="$1"
  action_keys["$1"]="$2"
}

map 'enter'                   'right'       "enter directory or edit file"
map 'enter2'                  'alt-l'       "enter directory or edit file"
map 'back'                    'left'        "go to parent directory (not moving past base directory)"
map 'back2'                   'alt-h'       "go to parent directory (not moving past base directory)"
map 'launch'                  'alt-q'       "quick-launch targets using native client"
map 'grep'                    'alt-/'       "grep for pattern specified at prompt ('left' will exit grep mode)"
map 'grep2'                   'ctrl-g'      "toggle grep mode / cancel submenu or prompt"
map 'move'                    'alt-m'       "move targets to directory named at prompt"
map 'rename'                  'alt-r'       "rename targets in current directory"
map 'move-rename'             'ctrl-alt-m'  "move/rename targets into directory named at prompt"
map 'move-rename2'            'ctrl-alt-r'  "move/rename targets into directory named at prompt"
map 'delete'                  'alt-x'       "delete targets"
map 'copy'                    'alt-c'       "copy targets to directory named at prompt"
map 'copy-rename'             'ctrl-alt-c'  "copy/rename targets into directory named at prompt"
map 'create-edit-file'        'alt-e'       "create/edit file named at prompt"
map 'create-file'             'alt-f'       "create file without editing"
map 'create-dir'              'alt-d'       "create directory named at prompt"
map 'create-enter-dir'        'ctrl-alt-d'  "create/enter directory named at prompt"
map 'bookmark-targets'        'alt-b'       "bookmark target directories"
map 'bookmark-current-dir'    'ctrl-alt-b'  "bookmark current directory"
map 'unbookmark-dirs'         'alt-u'       "unbookmark selected directories"
map 'unbookmark-current-dir'  'ctrl-alt-u'  "unbookmark current directory"
map 'next-bookmark'           'alt-right'   "go to next bookmarked directory"
map 'next-bookmark2'          'ctrl-alt-l'  "go to next bookmarked directory"
map 'prev-bookmark'           'alt-left'    "go to previous bookmarked directory"
map 'prev-bookmark2'          'ctrl-alt-h'  "go to previous bookmarked directory"
map 'select-bookmark'         'alt-up'      "select and enter bookmarked directory"
map 'select-bookmark2'        'ctrl-alt-k'  "select and enter bookmarked directory"
map 'select-nested-bookmark'  'alt-down'    "select and enter bookmarked directory under current directory"
map 'select-nested-bookmark2' 'ctrl-alt-j'  "select and enter bookmarked directory under current directory"
map 'set-alt-dir'             'alt-s'       "set alternate directory (default for copy/move prompts)"
map 'enter-alt-dir'           'alt-a'       "switch between current and alternate directory"
map 'enter-base-dir'          'alt-z'       "switch between current and base directory"
map 'enter-prev-dir'          'alt-p'       "switch between current and previous directory"
map 'prompt-dir'              'alt-g'       "go to directory named at prompt"
map 'set-base-dir'            'ctrl-alt-g'  "set new base directory at prompt and go to it"
map 'toggle-preview'          'ctrl-alt-p'  "toggle visibility of preview pane"
map 'toggle-status'           'ctrl-alt-t'  "toggle visibility of toggle status bar"
map 'toggle-ignored'          'alt-i'       "toggle visibility of ignored files (if supported)"
map 'toggle-hidden'           'alt-v'       "toggle visibility of hidden files"
map 'toggle-nested'           'alt-n'       "toggle listing nested vs. only top-level files"
map 'toggle-sort-order'       'alt-o'       "toggle sort order ascending/descending"
map 'toggle-sort'             'ctrl-alt-s'  "toggle sorted/unsorted results (affects performance)"
map 'reset-view'              'ctrl-alt-n'  "restore normal view settings (don't show nested/hidden/ignored)"
map 'load-session'            'alt-y'       "load session from file named at prompt"
map 'save-session'            'ctrl-alt-y'  "save session to file named at prompt"

# comma-separated list of custom mappings for fzf
fzf_keys="$(printf ",%s" "${keys[@]}" | cut -c2-)"

usage() {
cat <<USAGE
usage: $(basename "${BASH_SOURCE[0]}") [options] [target file or directory]

Browse files using fzf. If no target specified start in the current directory.

Key mappings:

$(awk -F ':' '{ printf("%-12s %-66s %s\n", $1, $2, $3) }' <(
cat <<KEY_USAGE
KEYMAP:DESCRIPTION:ACTION_NAME
escape:exit file browser
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${keys[@]}"; do echo "$k:${key_definitions[$k]}:${key_actions[$k]}"; done)
KEY_USAGE
))

Options:

--help,-h                          Show this help text
--once,-o                          Exit browser after editing a file
--color,-c                         Show colorized output
--recursive,-r                     List nested files/direcories at start
--hidden,-H                        Show hidden files/direcories at start
--no-ignore,-I                     Show ignored files/direcories at start
--no-sort,-S                       Disable sorting of files/directories
--reverse-sort,-R                  Reverse the normal sort order
--no-edit,-E                       Disable launch of editor and just log selection to file
--no-preview,-P                    Disable preview pane that shows file/directory contents
--no-toggle-status,-T              Disable status header that shows current toggle settings
--autosave-session,-s              Save bookmarks and view/sort settings continuously
--autoload-session,-l              Load bookmarks and view/sort settings at start
--grep=PATTERN,-g=PATTERN          Start in grep mode, searching files for specified pattern
--base-directory=DIR,-bd=DIR       Specify a base directory instead of deriving it from target
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start

Any additional options will be passed to fzf.
USAGE
}

for arg in "$@"; do
  case $arg in
    -h|--help) usage; exit 0 ;;
    -o|--once) persist=''; shift ;;
    -c|--color) color=1; shift ;;
    -r|--recursive) shallow=''; shift ;;
    -H|--hidden) hidden=1; shift ;;
    -I|--no-ignore) no_ignore=1; shift ;;
    -S|--no-sort) sorted=''; shift ;;
    -R|--reverse-sort) reverse=1; shift ;;
    -E|--no-edit) no_edit=1; persist=''; shift ;;
    -P|--no-preview) preview=''; shift ;;
    -T|--no-toggle-status) toggle_status=''; shift ;;
    -s|--autosave-session) autosave_session=1; shift ;;
    -l|--autoload-session) autoload_session=1; shift ;;
    -g=*|--grep=*) grep_mode=1; grep_query="${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) base_dir="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) alt_dir="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    # TODO: Capture non '=' style arguments 
    -*) fzf_extra_options+=("${arg%%=*}=\"${arg#*=}\""); shift ;;
  esac
done

save_selection() {
  if [[ $no_edit && -d $data_dir ]]; then
    selection="$data_dir/selection"
    mkdir -p "$(dirname $selection)" && touch "$selection"
    if [[ -w "$selection" ]]; then
      > "$selection"
      for t in "$@"; do
        if [[ -r "$t" ]]; then
          echo "$PWD/$t" >> "$selection"
        fi
      done
    fi
  fi
}

save_session() {
  if [[ -n "$1" ]]; then
    mkdir -p "$(dirname $1)" && touch "$1"
    if [[ -w "$1" ]]; then
      session="$1"
      readarray -t bookmarks < <(dirs -p -l)
      # Write session data to file
      declare -p PWD > "$session"
      [[ "$base_dir" ]] && declare -p base_dir >> "$session"
      [[ "$alt_dir" ]] && declare -p alt_dir >> "$session"
      declare -p bookmarks >> "$session"
      declare -p shallow >> "$session"
      declare -p hidden >> "$session"
      declare -p no_ignore >> "$session"
      declare -p sorted >> "$session"
      declare -p reverse >> "$session"
      declare -p preview >> "$session"
    else
      echo "Error: Could not save session to '$1'" 2>&1
      read -s -r -n 1 -p "(Press any key to continue)"
    fi
  fi
}

restore_session() {
  dirs -c
  pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
  for b in "${bookmarks[@]}"; do
    [[ -d "$b" ]] && pushd "$b" >/dev/null
  done
  cd "$base_dir"
}


initial_target="$1"

# Derive base directory from target, or use current directory if none given
if [[ -z "$base_dir" ]]; then
  [[ -d "$initial_target" ]] && base_dir="$initial_target" || base_dir="$(dirname "${initial_target:-$PWD/.}")"
fi
pushd "$base_dir" >/dev/null && pushd +1 >/dev/null

# Optionally autoload browsing session
init 'session' "${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
[[ $autoload_session && -r "$session" ]] && . -- "$session" && restore_session "$session"


main() {
  # Export variables for use in subshells
  export BZB_QUERY="$query"
  export BZB_COLOR="$color"
  export BZB_HIDDEN="$hidden"
  export BZB_NO_IGNORE="$no_ignore"
  export BZB_REVERSE="$reverse"

  # Edit file or enter directory
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
    # clear query after changing directory
    export BZB_QUERY=''
  elif [[ $# -ge 1 ]]; then
    edit="${EDITOR:vi}"
    for f in "$@"; do
      edit="$edit '$f'"
    done
    [[ $no_edit ]] && save_selection $@ || bash -c "$edit"
    [[ ! $persist ]] && exit 0
  fi

  # Setup list/sort/preview commands
  if [[ $grep_mode ]]; then
    export BZB_GREP_QUERY="$grep_query"
    [[ $shallow ]] && grep="$grep_shallow" || grep="$grep_recursive"
    preview_opts="--preview='$grep_mode_preview' --preview-window='$preview_window'"
    fzf_input=$(bash -c "echo \"$grep\"")
    fzf_prompt="/$grep_query/"
  else
    [[ $shallow ]] && find="$find_shallow" || find="$find_recursive"
    preview_opts="--preview='$find_mode_preview' --preview-window='$preview_window'"
    sort_pipe="${sorted:+ | $sort}"
    fzf_input=$(bash -c "echo \"$find$sort_pipe\"")
    fzf_prompt="${PWD#$base_dir}>"
  fi
  [[ ! $preview ]] && preview_opts=''

  # Clear leading dots from paths
  fzf_input+=" | sed 's:^\./::'"

  status=()
  [[ $shallow ]] && status+=('-n') || status+=('+N')
  [[ $hidden ]] && status+=('+H') || status+=('-h')
  [[ $no_ignore ]] && status+=('+I') || status+=('-i')
  [[ $sorted ]] && status+=('+S') || status+=('-s')
  [[ $reverse ]] && status+=('+R') || status+=('-r')
  export BZB_FZF_HEADER="[${status[@]}]"

  fzf_options="${no_clear:+--no-clear} --print-query --multi --layout='reverse' $fzf_bind --expect='$fzf_keys' --query='$BZB_QUERY' --prompt='$fzf_prompt' $preview_opts ${fzf_extra_options[@]}"
  [[ ! $color ]] && fzf_options="${color:---no-color} $fzf_options"
  [[ $toggle_status ]] && fzf_options="--header=\"\$BZB_FZF_HEADER\" $fzf_options"

  # CYCLE INTO FZF
  fzf_command="$fzf_input | fzf $fzf_options"
  { read query; read command; readarray -t targets; } < <(bash -c "$fzf_command")

  # Parse empty command and empty target as 'exit' (fzf-native 'escape' or 'ctrl-c' mapping)
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  # Parse empty command as 'enter' action
  [[ -z "$command" ]] && command='right'

  action="${key_actions[$command]}"

  next_targets=()
  case $action in
    # Use alt-/ to enter grep mode using search pattern specified at prompt
    # Use again to update search pattern. Enter empty pattern to cancel
    grep)
      clear && read -ep "Grep for Pattern: " -i "$grep_query" grep_query
      [[ $grep_query ]] && grep_mode=1 || grep_mode=''
    ;;

    # Use left arrow or alt-k to move up a directory, but not above base directory
    # If in grep mode, exit and resume browsing current directory
    back|back2)
      if [[ ! $grep_mode && "$PWD" != "$base_dir" ]]; then
        next_targets=("..")
      else
        next_targets=('.')
        grep_mode=''
      fi
    ;;

    # Exit grep-mode if any other directory navigation is used
    next-bookmark|next-bookmark2|prev-bookmark|prev-bookmark2|select-bookmark|select-bookmark2|select-nested-bookmark|select-nested-bookmark2|enter-base-dir|prompt-dir|set-base-dir|enter-alt-dir|enter-prev-dir)
      grep_mode=''
    # Fall through to remaining cases
    ;;&

    # Use ctrl-g to toggle in/out of grep mode (not changing search pattern)
    grep2)
      [[ $grep_mode ]] && grep_mode='' || grep_mode=1
    ;;

    # Use alt-n to toggle listing nested vs only top-level files/directories
    toggle-nested)
      [[ $shallow ]] && shallow='' || shallow=1
    ;;

    # Use alt-i to toggle visibility of ignored files/directories
    toggle-ignored)
      [[ $no_ignore ]] && no_ignore='' || no_ignore=1
    ;;

    # Use alt-v to toggle visibility of hidden files/directories
    toggle-hidden)
      [[ $hidden ]] && hidden='' || hidden=1
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    toggle-sort-order)
      [[ $reverse ]] && reverse='' || reverse=1
    ;;

    # Use ctrl-alt-s to enable/disable sorting
    toggle-sort)
      [[ $sorted ]] && sorted='' || sorted=1
    ;;

    # Use ctrl-alt-p to toggle visibility of preview pane
    toggle-preview)
      [[ $preview ]] && preview='' || preview=1
    ;;

    # Use ctrl-alt-t to toggle visibility of toggle status bar
    toggle-status)
      [[ $toggle_status ]] && toggle_status='' || toggle_status=1
    ;;

    # Use alt-q to quick-launch targets in their native client
    launch)
      if [[ "$launch" ]]; then
        for t in "${targets[@]}"; do
          bash -c "$launch '$t'"
        done
      fi
    ;;

    # Use alt-r to rename targets in current directory
    rename)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          clear && read -ep 'Move/Rename File: ' -i "mv \"$t\" \"$t\"" cmd
          [[ -n "$cmd" ]] && bash -c "$cmd"
        fi
      done
    ;;

    # Use alt-m to move targets
    move)
      clear && read -ep 'Move to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && mv -i "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-r or ctrl-alt-m to move and rename targets
    move-rename|move-rename2)
      clear && read -ep 'Move/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Move/Rename File: ' -i "mv '$PWD/$t' '${dir%/}/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-x to delete targets
    delete)
      CMD="$rm_interactive"
      for t in "${targets[@]}"; do
        CMD="$CMD '$t'"
      done
      clear && bash -c "$CMD"
    ;;

    # Use alt-c to copy targets
    copy)
      clear && read -ep 'Copy to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && cp -ir "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-c to copy and rename targets
    copy-rename)
      clear && read -ep 'Copy/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            clear && read -ep 'Copy/Rename File: ' -i "cp -ir '$PWD/$t' '$dir/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-d to create directory named at prompt
    # Use ctrl-alt-d to create directory and enter it
    create-dir|create-enter-dir)
      clear && read -p "Create directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = "${action_keys[create-enter-dir]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-f to create file named at prompt
    # Use alt-e to create file and edit it immediately
    create-file|create-edit-file)
      clear && read -p "Create file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = "${action_keys[create-edit-file]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to bookmark selected targets
    bookmark-targets)
      dir="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$dir/$b" ]]; then
          cd "$dir/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$dir"
    ;;

    # Use alt-u to select bookmarks to delete
    unbookmark-dirs)
      current_dir="$PWD"
      readarray -t dirs < <(dirs -p -l)
      bookmarks=("$(printf '%s\n' "${dirs[@]}" | LC_ALL=C sort -u | fzf $fzf_submenu_bind --multi --prompt='[unbookmark]')")
      for b in ${bookmarks[@]}; do
        for i in "${!dirs[@]}"; do
          if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$b" ]]; then
            popd -n +$i >/dev/null
          fi
        done
      done
      cd "$current_dir"
    ;;

    # Use ctrl-alt-b to bookmark current directory
    bookmark-current-dir)
      [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
    ;;

    # Use ctrl-alt-u to unbookmark current directory
    unbookmark-current-dir)
      for i in "${!dirs[@]}"; do
        if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$PWD" ]]; then
          popd +$i >/dev/null
        fi
      done
      pushd +1 >/dev/null 
    ;;

    # Use alt-right or ctrl-alt-l to go to next bookmarked directory
    next-bookmark|next-bookmark2)
      cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      fi
    ;;

    # Use alt-left or ctrl-alt-h to go to previous bookmarked directory
    prev-bookmark|prev-bookmark2)
      cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      fi
    ;;

    # Use alt-up or ctrl-alt-k to select bookmarked directory using fzf
    select-bookmark|select-bookmark2)
      readarray -t dirs < <(dirs -p -l | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf $fzf_submenu_bind --prompt='[go to directory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-down or ctrl-alt-j to select bookmarked directory under current directory
    select-nested-bookmark|select-nested-bookmark2)
      readarray -t dirs < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf $fzf_submenu_bind --prompt='[go to subdirectory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-p to go to previous directory
    enter-prev-dir)
      cd "$OLDPWD"
    ;;

    # Use alt-a to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    # Use alt-s to set alternate directory
    set-alt-dir|enter-alt-dir)
      if [[ "$action" = "set-alt-dir" || ! -d "$alt_dir" ]]; then
        clear && read -ep "Set alternate directory: " -i "$PWD" dir
        [[ -d "$dir" ]] && alt_dir="${dir%/}" || echo "Not a directory"
      fi
      if [[ "$action" = "enter-alt-dir" && -d "$alt_dir" ]]; then
        [[ "$PWD" = "$alt_dir" ]] && cd "$OLDPWD" || cd "$alt_dir"
      fi
    ;;

    # Use alt-g to go to directory named at prompt
    prompt-dir)
      clear && read -ep "Go to directory: " -i "$PWD" dir
      [[ -d "$dir" ]] && cd "$dir" || echo "Not a directory"
    ;;

    # Use ctrl-alt-g to set/enter new base directory
    # Use alt-z to go to base directory, or go back
    # to previous directory if already in base directory
    # Use alt-y to load session
    set-base-dir|enter-base-dir|load-session)
      dir="$PWD"
      if [[ "$action" = "set-base-dir" || ! -d "$base_dir" ]]; then
        clear && read -ep "Set base directory: " -i "$dir" dir
        if [[ -d "$dir" ]]; then
          base_dir="${dir%/}"
          pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
          session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
          action="autoload-session"
        fi
      fi
      if [[ ! -d "$base_dir" || ! -d "$dir" ]]; then
        echo "Error: Cannot set base directory to invalid path" 2>&1
        read -s -r -n 1 -p "(Press any key to continue)"
      elif [[ "$action" = "enter-base-dir" && "$PWD" = "$base_dir" ]]; then
        cd "$OLDPWD"
      else
        cd "$base_dir"
      fi
      if [[ "$action" = "load-session" || "$action" = "autoload-session" ]]; then
        restore="$session"
        if [[ "$action" = 'load-session' || ! $autoload_session ]]; then
          clear && read -ep "Load session: " -i "$restore" restore
        fi
        if [[ -r "$restore" ]]; then
          session="$restore"
          . -- "$session"
          restore_session
        fi
      fi
    ;;

    # Use ctrl-alt-y to save session
    save-session)
      clear && read -ep "Save session: " -i "$session" save
      save_session "$save"
    ;;

    # Use ctrl-alt-n to restore normal view/sort settings
    reset-view)
      shallow=1
      hidden=''
      no_ignore=''
      sorted=1
      reverse=''
      preview=1
    ;;

    # Use enter or right arrow or alt-j to edit file or enter directory
    enter|enter2)
      next_targets=("${targets[@]}")
    ;;
  esac

  # Optionally autosave browsing session
  [[ "$autosave_session" ]] && save_session "$session"

  main "${next_targets[@]}"
}

# Default initial target is current directory
main "${initial_target:-$base_dir}"
