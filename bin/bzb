#!/usr/bin/env bash
# File:         bzb
# Description:  Browse files using fzf.
# Version:      0.0.1
# License:      Copyright 2020 Brian Dellaterra.
#               Distributed under the terms of the GNU Lesser General Public License Version 2.1.
#               See the file LICENSE or <http://www.gnu.org/licenses/>.
set -e

script_name=$(basename "${BASH_SOURCE[0]}")

if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
  echo "Error: $script_name requires a newer version of bash" 1>&2
  exit 1
fi


# FUNCTIONS

# Test if command exists
has() { command -v "$1" &>/dev/null; }

# Test if variable is defined
defined() { [[ -n "$1" && -n "${!1+defined}" ]] || return 1; }

# Set global variable with name matching first argument to value provided as second argument
assign() {
  # Avoid polluting global namespace when setting variable if declare supports -g option (bash version 4.2+)
  if [[ "${BASH_VERSINFO[0]}" -ge 4 && "${BASH_VERSINFO[1]}" -ge 2 ]]; then
    declare -g "$1=$2"
  else
    export "$1=$2"
  fi
}

# In the variable name provided as first argument, store the default value provided
# as second argument. If BZB_ prefixed all-caps variable is defined use its value instead
init() {
  override="BZB_${1^^}"
  defined "$override" && assign "$1" "${!override}" || assign "$1" "$2"
}

# Initialize all variable names provided to true/on,
# allowing override by BZB_ prefixed all-caps variable only if previously unset
enable() {
  for var in "$@"; do
    defined "$var" && assign "$var" 1 || init "$var" 1
  done
}

# Initialize all variable names provided to false/off,
# allowing override by BZB_ prefixed all-caps variable only if previously unset
disable() {
  for var in "$@"; do
    defined "$var" && assign "$var" '' || init "$var" ''
  done
}

# Enable setting if disabled. Disable it if enabled
toggle() { [[ ${!1} ]] && disable "$1" || enable "$1"; }

# Escape single-quotes to make a single-quotable string
sq() { echo ${1//\'/\'\\\'\'}; }

# Escape special chars and newlines to make a double-quotable string
dq() {
  esc_chars='s/[$`"\]/\\&/g'
  echo "$1" | sed -e "$esc_chars" | (
    while read line; do echo -n "$(echo "$line" | sed -e "$esc_chars")\n"; done
  ) | sed -e 's/\\n$//'
}

# Leave alternate screen manually on exit after using fzf '--no-clear' option
clear_fzf() { [[ $fzf_command && $no_clear ]] && tput rmcup; }


# BINDINGS

# Set readline keybinds for cancelling prompts with ctrl-g or double-escape
# Binding single-escape could cause side effects due to its use as a common meta character
bind '"\C-g":"\C-k\C-u
"' '"\e\e":"\C-g"' &>/dev/null

# Set fzf keybinds for movement and exit actions
init fzf_bind '--bind=ctrl-g:ignore,esc:cancel'
init fzf_submenu_bind '--bind=ctrl-g:unix-line-discard+print-query,esc:unix-line-discard+print-query'

# Read overrides for action/key bindings to enable alternate keymaps
eval "declare -A BZB_BIND=( $BZB_BIND )"

declare -A key_definitions key_actions action_keys
map() {
  [[ "${BZB_BIND["$1"]}" ]] && key="${BZB_BIND[$1]}" || key="$2"
  keys[${#keys[@]}]="$key"
  key_definitions["$key"]="$3"
  key_actions["$key"]="$1"
  action_keys["$1"]="$key"
}

map 'exit'                    'esc'         "exit file browser"
map 'enter'                   'right'       "enter directory or edit file"
map 'back'                    'left'        "go to parent directory (not moving past base directory)"
map 'launch'                  'alt-q'       "(q)uick-launch targets using native client"
map 'grep'                    'alt-f'       "grep/(f)ind pattern specified at prompt ('left' will exit grep mode)"
map 'toggle-grep'             'ctrl-g'      "cancel submenu or prompt / toggle (g)rep mode preserving pattern"
map 'move'                    'alt-m'       "(m)ove targets to directory named at prompt"
map 'rename'                  'alt-r'       "(r)ename targets in current directory"
map 'move-rename'             'ctrl-alt-m'  "(m)ove/rename targets into directory named at prompt"
map 'delete'                  'alt-x'       "delete targets"
map 'copy'                    'alt-c'       "(c)opy targets to directory named at prompt"
map 'copy-rename'             'ctrl-alt-c'  "(c)opy/rename targets into directory named at prompt"
map 'create-file'             'alt-t'       "create (a.k.a. \"(t)ouch\") file named at prompt"
map 'create-edit-file'        'alt-e'       "create and (e)dit file named at prompt"
map 'create-dir'              'alt-d'       "create (d)irectory named at prompt"
map 'create-enter-dir'        'ctrl-alt-d'  "create/enter (d)irectory named at prompt"
map 'toggle-bookmark'         'alt-b'       "toggle (b)ookmark for current directory"
map 'bookmark-targets'        'ctrl-alt-b'  "(b)ookmark targets"
map 'unbookmark'              'ctrl-alt-u'  "(u)nbookmark selected directories"
map 'prev-bookmark'           'alt-left'    "jump backward through list of bookmarks"
map 'prev-bookmark2'          'alt-k'       "jump bac(k)ward through list of bookmarks"
map 'next-bookmark'           'alt-right'   "jump forward through list of bookmarks"
map 'next-bookmark2'          'alt-j'       "(j)ump forward through list of bookmarks"
map 'select-bookmark'         'alt-up'      "select and enter bookmarked directory"
map 'select-bookmark2'        'ctrl-alt-k'  "select and enter bookmarked directory"
map 'select-nested-bookmark'  'alt-down'    "select and enter bookmarked directory under current directory"
map 'select-nested-bookmark2' 'ctrl-alt-j'  "select and enter bookmarked directory under current directory"
map 'enter-alt-dir'           'alt-a'       "switch between current and (a)lternate directory"
map 'set-alt-dir'             'ctrl-alt-a'  "set (a)lternate directory (default for copy/move prompts)"
map 'up-base-dir'             'alt-u'       "go to base directory, or if at base move it (u)p one level"
map 'enter-prev-dir'          'alt-p'       "switch between current and (p)revious directory"
map 'prompt-dir'              'alt-g'       "(g)o to directory named at prompt"
map 'prompt-base-dir'         'ctrl-alt-g'  "set new base directory at prompt and (g)o to it"
map 'yank-targets'            'alt-y'       "copy (a.k.a. (y)ank) targets to clipboard"
map 'yank-dir'                'ctrl-alt-y'  "copy (a.k.a. (y)ank) current directory to clipboard"
map 'toggle-statusline'       'alt-l'       "toggle visibility of the status(l)ine"
map 'toggle-hide'             'alt-h'       "toggle visibility of (h)idden files"
map 'toggle-ignore'           'alt-i'       "toggle visibility of (i)gnored files (if supported)"
map 'toggle-nested'           'alt-n'       "toggle listing (n)ested vs. only top-level files"
map 'toggle-sort'             'alt-s'       "toggle (s)orting of results (affects performance)"
map 'toggle-nested-sort'      'ctrl-alt-n'  "toggle sorting of (n)ested results (affects performance)"
map 'toggle-sort-order'       'alt-o'       "toggle sort (o)rder ascending/descending"
map 'initial-settings'        'ctrl-alt-i'  "restore (i)nitial view/sort settings"
map 'toggle-preview'          'alt-v'       "toggle visibility of pre(v)iew pane"
map 'toggle-recording'        'ctrl-alt-r'  "record actions to file named at prompt"
map 'toggle-playback'         'ctrl-alt-p'  "playback actions from file named at prompt"
map 'load-session'            'ctrl-alt-l'  "(l)oad session from file named at prompt"
map 'save-session'            'ctrl-alt-s'  "(s)ave session to file named at prompt"
map 'terminal'                'ctrl-alt-t'  "open a new (t)erminal/shell in current directory"

# Comma-separated list of custom mappings for fzf
readonly fzf_keys="esc,$(printf ",%s" "${keys[@]}" | cut -c2-)"


# USAGE

usage() {
cat <<USAGE
usage: $script_name [options] [target file or directory]

Browse files using fzf. If no target is specified start in the current directory.

Options:

--help                             Show this help text
--color,-c                         Show colorized output
--nested,-n                        List nested files/directories at start
--no-hide,-H                       Show hidden files/directories at start
--no-ignore,-I                     Show ignored files/directories at start
--reverse,-O                       Reverse the normal sort order
--no-sort,-S                       Disable sorting of files/directories (affects performance)
--no-nested-sort,-NS               Disable sorting of nested files/directories (affects performance)
--no-statusline,-L                 Disable statusline that shows current state of various settings
--no-preview,-V                    Disable preview pane that shows file/directory contents
--no-persist,-P                    Exit browser after editing a file
--no-edit,-E                       Log selections to file instead of launching editor
--autosave-history,-ah             Save queries so Ctrl-p and Ctrl-n will cycle through search history
--autoload-query,-aq               Restore last query used in a directory upon entering it
--autosave-session,-as             Save bookmarks and view/sort settings continuously
--autoload-session,-al             Load bookmarks and view/sort settings on entering base directory
--autorecord,-ar                   Enable automatically recording actions to a file at start
--autoplay,-ap                     Enable automatically playing actions from a file at start
--recording-file=FILE,-rf=FILE     Specify target file for saving recorded actions
--playback-file=FILE,-pf=FILE      Specify source file for playing recorded actions
--base-directory=DIR,-bd=DIR       Specify base directory instead of deriving it from target argument
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start
--data-directory=DIR,-dd=DIR       Specify directory for storing sessions and other data
--grep=PATTERN,-g=PATTERN          Start in grep mode, searching files for specified pattern

Most options can be inverted by reversing uppercase/lowercase for the short form or adding/removing
the 'no-' prefix for the long form. Additional options will be passed on to fzf, with the long form using
an equals sign required for options that take values, unless no unescaped spaces are used in the assignment.
(e.g. '--query=STR' or '-qSTR', not '-q STR')

Key mappings:

$(awk -F ':' '{ printf("%-12s %-69s %s\n", $1, $2, $3) }' <(
cat <<KEY_USAGE
KEYMAP:DESCRIPTION:ACTION
ctrl-c:exit file browser
escape:clear search query / exit file browser if query is blank
enter:enter directory or edit file
$(for k in "${keys[@]}"; do echo "$k:${key_definitions[$k]}:${key_actions[$k]}"; done)
KEY_USAGE
))

Overrides for action/key bindings can be set using environment variable BZB_BIND.
For example, the 'launch' and 'enter' bindings can be swapped by invoking bzb with command:
> BZB_BIND="[enter]=alt-q [launch]=right" bzb
USAGE
}


# OPTIONS

for arg in "$@"; do
  case $arg in
    --help) usage; exit 0 ;;
    -c|--color) enable BZB_COLOR; shift ;;
    -C|--no-color) disable BZB_COLOR; shift ;;
    -n|--nested) enable BZB_NESTED; shift ;;
    -N|--no-nested) disable BZB_NESTED; shift ;;
    -h|--hide) enable BZB_HIDE; shift ;;
    -H|--no-hide) disable BZB_HIDE; shift ;;
    -i|--ignore) enable BZB_IGNORE; shift ;;
    -I|--no-ignore) disable BZB_IGNORE; shift ;;
    -o|--forward) disable BZB_REVERSE; shift ;;
    -O|--reverse) enable BZB_REVERSE; shift ;;
    -s|--sort) enable BZB_SORTED; shift ;;
    -S|--no-sort) disable BZB_SORTED; shift ;;
    -ns|--nested-sort) enable BZB_NESTED_SORT; shift ;;
    -NS|--no-nested-sort) disable BZB_NESTED_SORT; shift ;;
    -l|--statusline) enable BZB_STATUSLINE; shift ;;
    -L|--no-statusline) disable BZB_STATUSLINE; shift ;;
    -v|--preview) enable BZB_PREVIEW; shift ;;
    -V|--no-preview) disable BZB_PREVIEW; shift ;;
    -p|--persist) enable BZB_PERSIST; shift ;;
    -P|--no-persist) disable BZB_PERSIST; shift ;;
    -e|--edit) enable BZB_EDIT; shift ;;
    -E|--no-edit) disable BZB_EDIT; shift ;;
    -ah|--autosave-history) enable BZB_AUTOSAVE_HISTORY; shift ;;
    -AH|--no-autosave-history) disable BZB_AUTOSAVE_HISTORY; shift ;;
    -aq|--autoload-query) enable BZB_AUTOLOAD_QUERY; shift ;;
    -AQ|--no-autoload-query) disable BZB_AUTOLOAD_QUERY; shift ;;
    -as|--autosave-session) enable BZB_AUTOSAVE_SESSION; shift ;;
    -AS|--no-autosave-session) disable BZB_AUTOSAVE_SESSION; shift ;;
    -al|--autoload-session) enable BZB_AUTOLOAD_SESSION; shift ;;
    -AL|--no-autoload-session) disable BZB_AUTOLOAD_SESSION; shift ;;
    -ar|--autorecord) enable BZB_AUTORECORD; shift ;;
    -AR|--no-autorecord) disable BZB_AUTORECORD; shift ;;
    -ap|--autoplay) enable BZB_AUTOPLAY; shift ;;
    -AP|--no-autoplay) disable BZB_AUTOPLAY; shift ;;
    -rf=*|--recording-file=*=*) BZB_RECORDING_FILE="${arg#*=}"; shift ;;
    -pf=*|--playback-file=*=*) BZB_PLAYBACK_FILE="${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) BZB_BASE_DIR="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) BZB_ALT_DIR="${arg#*=}"; shift ;;
    -dd=*|--data-dir=*|--data-directory=*) BZB_DATA_DIR="${arg#*=}"; shift ;;
    -g=*|--grep=*) enable BZB_GREP_MODE; BZB_GREP_QUERY="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    -*) [[ "$arg" == *=* ]] && BZB_FZF_EXTRA_OPTIONS+=" ${arg%%=*}=\"${arg#*=}\"" || BZB_FZF_EXTRA_OPTIONS+=" \"$arg\""; shift ;;
  esac
done


# ARGUMENTS

initial_target="$1"
initial_targets=("$@") 


# SETTINGS

# Detect terminal/color-support and exit if not interactive
if [[ -t 0 || -p /dev/stdin ]]; then
  if has tput; then
    enable no_clear && readonly no_clear
    trap clear_fzf EXIT
    test $(tput colors) -ge 8 && enable color || disable color
  fi
else
  echo "Error: $script_name must be run interactively" 1>&2
  exit 1
fi

# Default behavior is to launch $EDITOR as the enter-action for files. Disabling the option
# below will instead only log selected targets to a 'selection' file inside 'data_dir'.
# This helps communicate user actions to an external program that has launched bzb as an
# integrated file browser. Disabling this option will also disable the 'persist' option
enable edit

# Default enabled/disabled settings
[[ $edit ]] && enable persist || disable persist
enable sorted preview statusline hide ignore
disable nested reverse autosave_history autoload_query autosave_session autoload_session autorecord autoplay grep_mode fzf_extra_options

# Derive base directory from target, or use current directory if none given
[[ -d "$initial_target" ]] && init base_dir "$initial_target" || init base_dir "$(dirname "${initial_target:-$PWD/.}")"
[[ ! "$(dirs -l)" =~ " $base_dir" ]] && pushd "$base_dir" >/dev/null && pushd +1 >/dev/null

# Files for recording and playing back actions not defined by default
disable recording_file
disable playback_file

# Alternate directory for quick naviagtion and file-operations not set by default 
disable alt_dir

# Directory where data for loading/restoring sessions is saved (optional)
init data_dir "$HOME/.bzb" && readonly data_dir

# Files for storing session data and fzf search history
init session "${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
[[ $autosave_history ]] && init search_history "${data_dir:+$data_dir/sessions$base_dir/search_history.bzb}"

# Dictionary for mapping directory to its last search query
declare -A directory_queries

# COMMANDS

# Find Commands: Prefer 'fd' over 'find' so ignored files are not listed
if has fd; then
  disable find_cannot_ignore
  init find_nested \
    "fd \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
  init find_shallow \
    "fd --max-depth 1 \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
else
  enable find_cannot_ignore
  init find_nested \
    "find . -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
  init find_shallow \
    "find . -maxdepth 1 -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
fi
readonly find_cannot_ignore

# Sort Command:
enable parallel_sort
init sort_shallow \
  "LC_ALL=C sort \$([[ \$BZB_SORT_NUMERIC ]] && echo '-g' || echo '-fiu') \${BZB_REVERSE:+-r}"
if has parallel && test $parallel_sort; then
  enable nested_sort
  init sort_nested \
    "LC_ALL=C parallel --pipe --block 64k sort \$([[ \$BZB_SORT_NUMERIC ]] && echo '-g' || echo '-fiu') \${BZB_REVERSE:+-r} 2>/dev/null"
else
  disable parallel_sort
  disable nested_sort
  init sort_nested "$sort_shallow"
fi
readonly parallel_sort

# Preview Commands:
init preview_directory \
  "ls \${BZB_COLOR:+--color=always} \${BZB_HIDDEN:+-a} -lh {}"
init preview_text \
  "cat {}"
# Consider file to be binary if more than a tiny fraction is non-printable characters
init is_binary \
  '( test $(head -qc 8192 {} 2>/dev/null | grep -so "[^[:print:]]" 2>/dev/null | wc -c) -gt 16 )'

if has file; then
  init preview_binary_file \
    "file -L {}"
  init is_binary \
    "( $is_binary"' || ( file -L {} | grep -q "compressed") )'
else
  init preview_binary_file \
    "stat -L {}"
fi

if has less; then
  init is_previewable_binary_content \
    '[[ $(bash -c "$(printf "$LESSOPEN" {})") ]]'
  init preview_binary_content \
    'echo && less {}'
else
  disable is_previewable_binary_content preview_binary_content
fi

[[ $is_previewable_binary_content && $preview_binary_content ]] && init \
  preview_binary_file "( $preview_binary_file && $is_previewable_binary_content && $preview_binary_content )"
init preview_file \
  "( ! $is_binary && $preview_text || $preview_binary_file )"
init find_mode_preview \
  "[[ -d {} ]] && $preview_directory || $preview_file"

# Clear leading dots from paths
no_leading_dots="| sed 's:^\./::'"

# Clear numeric count from beginning of grep results
no_grep_counts="| sed -e 's/^[0-9]\+ //g'"

# Grep Commands: Prefer 'rg' over 'grep' so ignored files are not listed. (Uses '-c' for number of matches per file)
no_zero_counts="| grep -v ':0$'"
list_by_grep_count="$no_zero_counts | awk -F ':' '$(dq "$(sq '{ printf( "%s %s\n", $2, $1 ) }')")'"
escape_grep_results="| sed -e '$(sq 's/\s\|'\''/\\\&/g')'"
if has rg; then
  disable grep_cannot_ignore
  init grep_nested \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --count --ignore-case --no-messages '\${BZB_GREP_QUERY}' . $no_leading_dots $list_by_grep_count"
  init grep_shallow \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --count --maxdepth 1 --ignore-case --no-messages '\${BZB_GREP_QUERY}' . $no_leading_dots $list_by_grep_count "
  init grep_mode_preview \
    "echo {} $no_grep_counts $escape_grep_results | xargs cat | rg \${BZB_COLOR:+--color} \${BZB_COLOR:+always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --ignore-case --no-messages --context 1 '\${BZB_GREP_QUERY}'"
else
  enable grep_cannot_ignore
  init grep_nested \
    "grep -r -i -s -c '\${BZB_GREP_QUERY}' .\${BZB_HIDDEN+ | grep -v '.*\/\..*'}$no_leading_dots $list_by_grep_count"
  init grep_shallow \
    "grep -i -s -c '\${BZB_GREP_QUERY}' "'$([[ $BZB_HIDDEN ]] && echo "*" || echo "{*,.*}")'"$no_leading_dots $list_by_grep_count"
  init grep_mode_preview \
    "echo {} $no_grep_counts $escape_grep_results | xargs cat | grep \${BZB_COLOR:+--color=always} -i -s -C 1 '\${BZB_GREP_QUERY}'"
fi
readonly grep_cannot_ignore
disable grep_query

# Quick-launch Command: Used to open targets in their native client
init launch ''
has xdg-open && init launch 'xdg-open'
has open && init launch 'open'

# Clip Command: Used to copy text to clipboard
init clip ''
has xclip && init clip 'xclip'
has clip && init clip 'clip'

# Prefer -I option to -i for removing files, if available
rm -I '' 2>&1 | grep '\(unrecognized\|invalid\) option' &>/dev/null && \
  init rm_interactive 'rm -ri' || init rm_interactive 'rm -rI'


# FILE STATE

[[ $search_history ]] && mkdir -p "$(dirname "$search_history")" && touch "$search_history"

save_selection() {
  if [[ -d "$data_dir" ]]; then
    selection="$data_dir/selection"
    mkdir -p "$(dirname "$selection")" && touch "$selection"
    if [[ -w "$selection" ]]; then
      > "$selection"
      for t in "$@"; do
        if [[ -r "$t" ]]; then
          echo "$PWD/$t" >> "$selection"
        fi
      done
    fi
  fi
}

save_session() {
  if [[ -n "$1" ]]; then
    mkdir -p "$(dirname "$1")" && touch "$1"
    if [[ -w "$1" ]]; then
      session="$1"
      readarray -s 1 -t bookmarks < <(dirs -p -l)
      # Write session data to file
      declare -p PWD > "$session"
      [[ "$base_dir" ]] && declare -p base_dir >> "$session"
      [[ "$alt_dir" ]] && declare -p alt_dir >> "$session"
      declare -p bookmarks hide ignore nested sorted nested_sort reverse preview statusline >> "$session"
      [[ "$grep_query" ]] && declare -p grep_query >> "$session"
      [[ ${#directory_queries[@]} ]] && declare -p directory_queries >> "$session"
    else
      echo "Error: Could not save session to '$1'" 2>&1
      read -s -r -n 1 -p "(Press any key to continue)"
    fi
  fi
}

restore_session() {
  dirs -c
  for b in "${bookmarks[@]}"; do
    [[ -d "$b" && ! "$(dirs -l)" =~ " $b" ]] && pushd "$b" >/dev/null && pushd +1 >/dev/null
  done
  [[ ! "$(dirs -l)" =~ " $base_dir" ]] && pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
  pushd "$base_dir" >/dev/null
}

path_error() {
  printf "\nError: ${1:-Not a directory.}${2:- Use 'Tab' key for path completion.\n}" 2>&1
  printf "${3:-Add a backslash '\\\\' before spaces and special characters below:\n\\\\ \$ \` \' \"\n\n}" 2>&1
  read -s -r -n 1 -p "(Press any key to continue)"
}


# MAIN

# Save initial preferences so they can be restored later
declare -A initial_settings=([sorted]="$sorted" [preview]="$preview" [statusline]="$statusline" [hide]="$hide" [ignore]="$ignore" [nested]="$nested" [reverse]="$reverse" [nested_sort]="$nested_sort")

# Optionally autoload browsing session
[[ $autoload_session && -r "$session" ]] && . -- "$session" && restore_session "$session"

main() {
  # Export variables for use in subshells
  export BZB_BASE_DIR="$base_dir"
  export BZB_QUERY="$query"
  export BZB_COLOR="$color"
  [[ $hide ]] && export BZB_HIDDEN=1 || export BZB_HIDDEN=''
  [[ $ignore ]] && export BZB_NO_IGNORE='' || export BZB_NO_IGNORE=1
  export BZB_REVERSE="$reverse"
  export BZB_SORT_NUMERIC=""
  export BZB_GREP_QUERY="$(sq "$grep_query")" # escaped for single-quoting here

  # Clear any stale selection so it is not read on esc/ctrl-c exit action
  save_selection

  # Edit file or enter directory
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
  elif [[ $# -ge 1 ]]; then
    edit_targets="${EDITOR:vi}"
    for f in "$@"; do
      edit_targets+=" '$(sq "$f")'"
    done
    [[ $edit ]] && bash -c "$edit_targets" || save_selection "$@"
    [[ ! $persist ]] && exit 0
  fi

  # Clear or optionally restore query after changing directory
  if [[ "$PWD" != "$BZB_DIR" ]]; then
    [[ $autoload_query ]] && export BZB_QUERY="${directory_queries[$PWD]}" || export BZB_QUERY=''
  fi

  # Export current directory
  export BZB_DIR="$PWD"

  # Setup list/sort/preview commands
  [[ $nested ]] && sort="$sort_nested" || sort="$sort_shallow"
  [[ ! $nested || $nested_sort ]] && sort_pipe="${sorted:+ | $sort}" || sort_pipe=''
  if [[ $grep_mode ]]; then
    # Order grep results by number of matches descending
    enable BZB_SORT_NUMERIC && toggle BZB_REVERSE
    [[ $nested ]] && grep="$grep_nested" || grep="$grep_shallow"
    fzf_prompt=" --prompt='/$BZB_GREP_QUERY/'"
    fzf_input=$(bash -c "echo \"$grep$sort_pipe\"")
    fzf_preview=$(bash -c "echo \"$grep_mode_preview\"")
    [[ $grep_cannot_ignore ]] && ignore_disabled='!' || ignore_disabled=''
  else
    [[ $nested ]] && find="$find_nested" || find="$find_shallow"
    fzf_prompt=" --prompt='"$(sq "${BZB_DIR#$BZB_BASE_DIR}")">'"   
    fzf_input=$(bash -c "echo \"$find$sort_pipe\"")
    fzf_preview="$find_mode_preview"
    [[ $find_cannot_ignore ]] && ignore_disabled='!' || ignore_disabled=''
  fi
  fzf_input+="$no_leading_dots"

  # Prepare display to show status of toggle-settings
  status=()
  [[ $hide ]] && status+=('-h') || status+=('-H')
  [[ $ignore ]] && status+=("${ignore_disabled:--}i") || status+=("${ignore_disabled:--}I")
  [[ $nested ]] && status+=('-n') || status+=('-N')
  [[ $nested_sort ]] && nested_sort_enabled="/" || nested_sort_enabled='' 
  [[ ! $sorted ]] && sort_disabled='-' || sort_disabled=''
  [[ $sorted ]] && sort_enabled='-' || sort_enabled=''
  [[ $nested && $sort_enabled && $parallel_sort ]] && sort_enabled="="
  [[ $nested && ! $nested_sort_enabled ]] && sort_disabled='!' && sort_enabled='!'
  [[ $sorted && $sort_enabled ]] && status+=("${sort_enabled}s${nested_sort_enabled}") || status+=("${sort_disabled}S${nested_sort_enabled}")
  [[ ! $sorted || $sort_disabled ]] && reverse_disabled='!' || reverse_disabled=''
  [[ $reverse ]] && status+=("${reverse_disabled:--}O") || status+=("${reverse_disabled:--}o")

  export BZB_STATUSLINE="[${status[@]}]"

  fzf_options="${no_clear:+--no-clear} --print-query --multi --layout='reverse' $fzf_bind --expect='$(sq "$fzf_keys")' --query=\"\$BZB_QUERY\" $fzf_prompt"
  [[ ! $color ]] && fzf_options+=" ${color:---no-color}"
  [[ $grep_mode ]] && fzf_options+=" --nth=2"
  [[ $statusline ]] && fzf_options+=" --header=\"\$BZB_STATUSLINE\""
  [[ $preview ]] && fzf_options+=" --preview='$(sq "$fzf_preview")' --preview-window='right:62%:wrap'"
  [[ $search_history ]] && fzf_options+=" --history='$(sq "$search_history")'"
  [[ $fzf_extra_options ]] && fzf_options+=" $fzf_extra_options"

  # CYCLE INTO FZF
  fzf_command="$fzf_input | fzf $fzf_options"
  [[ $grep_mode ]] && fzf_command+="$no_grep_counts"
  { read query; read command; readarray -t targets; } < <(bash -c "$fzf_command")

  # Optionally preserve query for current directory
  [[ $autoload_query && $query ]] && directory_queries[$BZB_DIR]="$query"

  # Parse empty command and empty target as 'exit' (fzf-native 'ctrl-c' mapping)
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  # Parse empty command as 'enter' action
  [[ -z "$command" ]] && command='right'

  assign action "${key_actions[$command]}"

  next_targets=()

  case $action in
    # Exit grep-mode if any directory navigation action occurs ('back' is a special case below)
    next-bookmark|next-bookmark2|prev-bookmark|prev-bookmark2|select-bookmark|select-bookmark2|select-nested-bookmark|select-nested-bookmark2|up-base-dir|prompt-dir|set-base-dir|prompt-base-dir|enter-alt-dir|enter-prev-dir)
      disable grep_mode
    ;;

  # Fall through to remaining cases
  esac; case $action in

    # Use left arrow to move up a directory, but not above base directory
    # If in grep mode, exit and resume browsing current directory
    back)
      if [[ ! $grep_mode && "$PWD" != "$base_dir" ]]; then
        next_targets=("..")
      else
        next_targets=('.')
        disable grep_mode
      fi
    ;;

    # Use enter or right arrow to edit file or enter directory
    enter)
      next_targets=("${targets[@]}")
    ;;

    # Use alt-f to enter grep mode using search pattern specified at prompt
    # Use again to update search pattern. Enter empty pattern to cancel
    grep)
      clear && read -ep "Grep for Pattern: " -ri "$grep_query" next_query
      if [[ $next_query ]]; then
        enable grep_mode
        grep_query="$next_query"
      else
        disable grep_mode
      fi
    ;;

    # Use ctrl-g to toggle in/out of grep mode (not changing search pattern)
    toggle-grep)
      toggle grep_mode
    ;;

    # Use alt-n to toggle listing nested vs only top-level files/directories
    toggle-nested)
      toggle nested
    ;;

    # Use alt-i to toggle visibility of ignored files/directories
    toggle-ignore)
      toggle ignore
    ;;

    # Use alt-h to toggle visibility of hidden files/directories
    toggle-hide)
      toggle hide
    ;;

    # Use alt-s to enable/disable sorting
    toggle-sort)
      toggle sorted
    ;;

    # Use ctrl-alt-n to enable/disable nested sorting
    toggle-nested-sort)
      toggle nested_sort
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    toggle-sort-order)
      toggle reverse
    ;;

    # Use alt-v to toggle visibility of preview pane
    toggle-preview)
      toggle preview
    ;;

    # Use alt-l to toggle visibility of statusline
    toggle-statusline)
      toggle statusline
    ;;

    # Use ctrl-alt-r to toggle recording actions to file named at prompt
    toggle-recording)
      if [[ $autorecord || ! $autoplay ]]; then
        [[ -w "$playback_file" && ! $recording_file ]] && default_file="$playback_file" || default_file="$recording_file"
        clear && read -ep "Record actions to file: " -i "$default_file" file
        if [[ "$playback_file" -ef "$file" ]]; then
          echo "Error: Cannot record to a file that is currently playing back" 2>&1
          [[ ! $autoplay ]] && read -s -r -n 1 -p "(Press any key to continue)"
        elif [[ ! -w "$file" ]]; then
          echo "Error: Cannot record actions to file without write permission" 2>&1
          [[ ! $autoplay ]] && read -s -r -n 1 -p "(Press any key to continue)"
        else
          assign recording_file "$file" && toggle action-record
        fi
      fi
    ;;

    # Use ctrl-alt-p to playback recording from file named at prompt
    toggle-playback)
      if [[ $autoplay || ! $autorecord ]]; then
        [[ -r "$recording_file" && ! $playback_file ]] && default_file="$recording_file" || default_file="$playback_file"
        clear && read -ep "Playback actions from file: " -i "$default_file" file
        if [[ "$recording_file" -ef "$file" ]]; then
          echo "Error: Cannot playback from a file that is currently recording" 2>&1
          [[ ! $autoplay ]] && read -s -r -n 1 -p "(Press any key to continue)"
        elif [[ ! -r "$file" ]]; then
          echo "Error: Cannot playback actions from file without read permission" 2>&1
          [[ ! $autoplay ]] && read -s -r -n 1 -p "(Press any key to continue)"
        else
          assign playback_file "$file" && toggle action-playback
        fi
      fi
    ;;

    # Use ctrl-alt-i to restore initial view/sort settings
    initial-settings)
      for i in ${!initial_settings[@]}; do
        [[ ${initial_settings[$i]} ]] && enable "$i" || disable "$i"
      done
    ;;

    # Use alt-y to yank targets to clipboard
    yank-targets)
      yank_targets=''
      for t in "${targets[@]}"; do
        yank_targets+=" '$(sq "$PWD/$t")'"
      done
      [[ "$clip" ]] && bash -c "echo -n '$(sq "$yank_targets")' | $clip"
    ;;

    # Use ctrl-alt-y to yank current directory to clipboard
    yank-dir)
      yank_directory=" '$(sq "$PWD")'"
      [[ "$clip" ]] && bash -c "echo -n '$(sq "$yank_directory")' | $clip"
    ;;

    # Use alt-q to quick-launch targets in their native client
    launch)
      if [[ "$launch" ]]; then
        for t in "${targets[@]}"; do
          bash -c "$launch '$t'"
        done
      fi
    ;;

    # Use alt-r to rename targets in current directory
    rename)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          clear && read -r -ep 'Move/Rename File: ' -i "mv '$(sq "$t")' '$(sq "$t")'" cmd
          [[ -n "$cmd" ]] && bash -c "$cmd"
        fi
      done
    ;;

    # Use alt-m to move targets
    move)
      clear && read -ep 'Move to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && mv -i "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-m to move and rename targets
    move-rename)
      clear && read -ep 'Move/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -r -ep 'Move/Rename File: ' -i "mv '$(sq "$PWD/$t")' '$(sq "${dir%/}/$t")'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-x to delete targets
    delete)
      delete_targets=''
      for t in "${targets[@]}"; do
        delete_targets+=" '$(sq "$t")'"
      done
      echo "$rm_interactive $delete_targets"
      clear && bash -c "$rm_interactive $delete_targets"
    ;;

    # Use alt-c to copy targets
    copy)
      clear && read -ep 'Copy to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && cp -ir "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-c to copy and rename targets
    copy-rename)
      clear && read -ep 'Copy/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            clear && read -r -ep 'Copy/Rename File: ' -i "cp -ir '$(sq "$PWD/$t")' '$(sq "$dir/$t")'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-d to create directory named at prompt
    # Use ctrl-alt-d to create directory and enter it
    create-dir|create-enter-dir)
      [[ "$action" = "create-enter-dir" ]] && create_enter="Create/Enter" || create_enter="Create"
      clear && read -r -ep "$create_enter directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = "${action_keys[create-enter-dir]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-t to "touch" or create file named at prompt
    # Use alt-e to create file and edit it immediately
    create-file|create-edit-file)
      [[ "$action" = "create-edit-file" ]] && create_edit="Create/Edit" || create_edit="Create"
      clear && read -r -ep "$create_edit file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = "${action_keys[create-edit-file]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to toggle bookmark for current directory
    toggle-bookmark)
      current_dir="$PWD"
      readarray -s 1 -t bookmarks < <(dirs -p -l)
      if [[ "$(dirs -l)" =~ " $current_dir" ]]; then
        for i in "${!bookmarks[@]}"; do
          if [[ "$current_dir" = "${bookmarks[$i]}" && ! "$current_dir" = "$base_dir" ]]; then
            popd -n +$((i+1)) >/dev/null
          fi
        done
      else
        pushd "$current_dir" >/dev/null && pushd +1 >/dev/null
      fi
    ;;

    # Use ctrl-alt-b to bookmark targets
    bookmark-targets)
      current_dir="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$current_dir/$b" ]]; then
          # Use $PWD for full path
          cd "$current_dir/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$current_dir"
    ;;

    # Use ctrl-alt-u to select bookmarks to delete
    unbookmark)
      current_dir="$PWD"
      readarray -s 1 -t bookmarks < <(dirs -p -l)
      # base_dir must stay bookmarked and is omitted from selection menu
      readarray -t bookmarks < <(printf '%s\n' "${bookmarks[@]}" | sed -n '/^'"${base_dir//\//\\/}"'$/!p')
      if [[ "${#bookmarks[@]}" -gt 0 ]]; then
        unmarks=("$(printf '%s\n' "${bookmarks[@]}" | LC_ALL=C sort -ru | fzf $fzf_submenu_bind --multi --prompt='[unbookmark]')")
        for b in ${unmarks[@]}; do
          readarray -t bookmarks < <(dirs -p -l)
          for i in "${!bookmarks[@]}"; do
            [[ $i -ge 1 && "${bookmarks[$i]}" = "$b" ]] && popd -n +$i >/dev/null
          done
        done
      else
        clear && echo "No bookmarks to delete." 2>&1
        read -s -r -n 1 -p "(Press any key to continue)"
      fi
      cd "$current_dir"
    ;;

    # Use alt-right or alt-j to go to next bookmarked directory
    next-bookmark|next-bookmark2)
      cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      fi
    ;;

    # Use alt-left or alt-k to go to previous bookmarked directory
    prev-bookmark|prev-bookmark2)
      cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      fi
    ;;

    # Use alt-up or ctrl-alt-k to select bookmarked directory using fzf
    select-bookmark|select-bookmark2)
      # Omit current directory from bookmarks then position it as initial selection at bottom of list
      readarray -t dirs < <(dirs -p -l | sed -n '/^'"${PWD//\//\\/}"'$/!p' | LC_ALL=C sort -u)
      dirs=("$PWD" ${dirs[@]})
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf $fzf_submenu_bind --prompt='[go to directory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-down or ctrl-alt-j to select bookmarked directory under current directory
    select-nested-bookmark|select-nested-bookmark2)
      readarray -t dirs < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf $fzf_submenu_bind --prompt='[go to subdirectory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-p to go to previous directory
    enter-prev-dir)
      cd "$OLDPWD"
    ;;

    # Use alt-a to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    # Use ctrl-alt-a to set alternate directory
    set-alt-dir|enter-alt-dir)
      if [[ "$action" = "set-alt-dir" || ! -d "$alt_dir" ]]; then
        clear && read -ep "Set alternate directory: " -i "$PWD" dir
        if [[ -d "$dir" ]]; then
          alt_dir="${dir%/}"
        else
          path_error
        fi
      fi
      if [[ "$action" = "enter-alt-dir" && -d "$alt_dir" ]]; then
        [[ "$PWD" = "$alt_dir" ]] && cd "$OLDPWD" || cd "$alt_dir"
      fi
    ;;

    # Use alt-g to go to directory named at prompt
    prompt-dir)
      clear && read -ep "Go to directory: " -i "$PWD" dir
      if [[ -d "$dir" ]]; then
        cd "$dir"
      else
        path_error
      fi
    ;;

    # Use ctrl-alt-g to set/enter new base directory
    # Use alt-u to go "up" to base directory,
    # shifting up to parent directory if already at base
    prompt-base-dir|up-base-dir)
      dir="$PWD"
      next_base=""
      if [[ "$action" = "prompt-base-dir" || ! -d "$base_dir" ]]; then
        clear && read -ep "Set base directory: " -i "$dir" dir
        next_base="${dir%/}"
      elif [[ "$action" = "up-base-dir" ]]; then
        [[ "$PWD" = "$base_dir" ]] && next_base="$(dirname "$dir")" || cd "$base_dir"
      fi
      if [[ -n "$next_base" ]]; then
        if [[ ! -d "$next_base" ]]; then
          path_error
        elif [[ "$next_base" != "$base_dir" ]]; then
          base_dir="$(cd "$next_base" && pwd -P)"
          [[ ! "$(dirs -l)" =~ " $base_dir" ]] && pushd "$base_dir" >/dev/null
          session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
          assign action "autoload-session"
        fi
      fi
    ;;

    # Use ctrl-alt-t to open a new terminal/shell in current directory
    terminal)
      clear && $SHELL
    ;;

  # Fall through to remaining cases
  esac; case $action in

    # Use ctrl-alt-l to load session. May be triggered automatically by other actions,
    # in which case prompt will still appear if autoload_session setting is disabled
    load-session|autoload-session)
      session_file="$session"
      if [[ "$action" = 'load-session' || ! $autoload_session ]]; then
        clear && read -ep "Load session: " -i "$session_file" session_file
        [[ $session_file && ! -r "$session_file" ]] && path_error 'Cannot read session file.'
      fi
      if [[ -r "$session_file" ]]; then
        session="$session_file"
        . -- "$session"
        restore_session
      fi
    ;;

    # Use ctrl-alt-s to save session
    save-session)
      clear && read -ep "Save session: " -i "$session" session_file
      if [[ $session_file ]]; then
        [[ -w "$session_file" ]] && save_session "$session_file" || path_error 'Cannot write session file.'
      fi
    ;;
  esac

  # Optionally autosave browsing session
  [[ $autosave_session ]] && save_session "$session"

  # Loop until terminated
  [[ "$action" = 'exit' ]] && exit 0 || main "${next_targets[@]}"
}

# Default initial target is current directory
main "${initial_target:-$base_dir}" ${initial_targets[@]:1}
