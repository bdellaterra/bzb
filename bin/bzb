#!/bin/bash
set -e

script_name=$(basename "${BASH_SOURCE[0]}")

if [[ "${BASH_VERSINFO[0]}" -lt 4 ]]; then
  echo "Error: $script_name requires a newer version of bash" 1>&2
  exit 1
fi


# FUNCTIONS

# Test if command exists
has() { command -v "$1" &>/dev/null; }

# Test if variable is set. Set it to second argument if provided
# TODO: Find function name that doesn't override bash-native 'set' command
set() {
  if [[ -n "${2+defined}" ]]; then
    # Avoid polluting global namespace when setting variable if declare supports -g option (bash version 4.2+)
    if [[ "${BASH_VERSINFO[0]}" -ge 4 && "${BASH_VERSINFO[1]}" -ge 2 ]]; then
      declare -g "$1=$2"
    else
      export "$1=$2"
    fi
  fi
  [[ -n "$1" && -n "${!1+defined}" ]] || return 1
}

# In the variable name provided as first argument, store the default value provided
# as second argument. If BZB_ prefixed all-caps variable is defined use its value instead
init() {
  override="BZB_${1^^}"
  set "$override" && set "$1" "${!override}" || set "$1" "$2"
}

# Initialize variable names provided to true/on value,
# allowing override by BZB_ prefixed all-caps variable only if previously unset
enable() {
  for var in "$@"; do
    set "$var" && set "$var" 1 || init "$var" 1
  done
}

# Initialize variable name provided as first argument to false/off value,
# allowing override by BZB_ prefixed all-caps variable only if previously unset
disable() {
  for var in "$@"; do
    set "$var" && set "$var" '' || init "$var" ''
  done
}

# Enable setting if false/off. Disable it if true/on
toggle() { [[ ${!1} ]] && disable "$1" || enable "$1"; }

# Leave alternate screen manually on exit after using fzf '--no-clear' option
clear_fzf() {
  [[ $fzf_command && $no_clear ]] && tput rmcup
}


# SETTINGS

# Detect terminal/color-support and exit if not interactive
if [[ -t 0 || -p /dev/stdin ]]; then
  if has tput; then
    enable no_clear && readonly no_clear
    trap clear_fzf EXIT
    test $(tput colors) -ge 8 && enable color || disable color
  fi
else
  echo "Error: $script_name must be run interactively" 1>&2
  exit 1
fi

# Additional options to be passed to fzf
disable fzf_extra_options

# Directory where data for loading/restoring sessions is saved (optional)
init data_dir "$HOME/.bzb" && readonly data_dir

# Default behavior is to launch $EDITOR as the enter-action for files. Enabling the option
# below will instead only log selected targets to a 'selection' file inside 'data_dir'.
# This helps communicate user actions to an external program that has launched bzb as an
# integrated file browser. Enabling this option will disable the 'persist' option
disable no_edit

# Default enabled/disabled settings
enable persist shallow sorted preview toggle_status hide
disable reverse no_ignore grep_mode autosave_session autoload_session


# COMMANDS

# Find Commands: Prefer 'fd' over 'find' so ignored files are not listed
if has fd; then
  disable no_find_ignore_status
  init find_recursive \
    "fd \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
  init find_shallow \
    "fd --max-depth 1 \${BZB_COLOR:+--color always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore}"
else
  enable no_find_ignore_status
  init find_recursive \
    "find . -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
  init find_shallow \
    "find . -maxdepth 1 -not -name '.' \${BZB_HIDDEN:+-not -path '*/.*'}"
fi
readonly no_find_ignore_status

# Sort Command:
enable parallel_sort
init sort_shallow \
  "LC_ALL=C sort \${BZB_REVERSE:+-r} -fiu"
if has parallel && test $parallel_sort; then
  enable nested_sort
  init sort_recursive \
    "LC_ALL=C parallel --pipe --block 64k sort \${BZB_REVERSE:+-r} -fiu 2>/dev/null"
else
  disable parallel_sort
  disable nested_sort
  init sort_recursive "$sort_shallow"
fi
readonly parallel_sort

# Preview Commands:
init preview_directory \
  "ls \${BZB_COLOR:+--color=always} \${BZB_HIDDEN:+-a} -lh {}"
init preview_text \
  "cat {}"
init is_binary \
  'test `head -qc 8192 {} 2>/dev/null | grep -o "[^[:print:]]" 2>/dev/null | wc -c` -gt 16'

if has file; then
  init preview_binary \
    "file -L {}"
  init is_binary \
    '[[ ! "$(file -L {})" =~ 'text' ]] && '"$is_binary"
else
  init preview_binary \
    "stat -L {}"
fi

init preview_file \
  "( $is_binary && $preview_binary || $preview_text )"
init find_mode_preview \
  "[[ -d {} ]] && $preview_directory || $preview_file"

# Grep Commands: Prefer 'rg' over 'grep' so ignored files are not listed
if has rg; then
  disable no_grep_ignore_status
  init grep_recursive \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  init grep_shallow \
    "rg \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --max-depth 1 --files-with-matches --ignore-case --no-messages '\${BZB_GREP_QUERY}' ."
  init grep_mode_preview \
    "rg \${BZB_COLOR:+--color} \${BZB_COLOR:+always} \${BZB_HIDDEN:+--hidden} \${BZB_NO_IGNORE:+--no-ignore} --ignore-case --no-messages --context 1 '\${BZB_GREP_QUERY}' '{}'"
else
  enable no_grep_ignore_status
  init grep_recursive \
    "grep -r -l -i -s -C 1 '\${BZB_GREP_QUERY}' .\${BZB_HIDDEN+ | grep -v '.*\/\..*'}"
  init grep_shallow \
    "grep -l -i -s -C 1 '\${BZB_GREP_QUERY}' "'$([[ $BZB_HIDDEN ]] && echo "*" || echo "{*,.*}")'
  init grep_mode_preview \
    "grep \${BZB_COLOR:+--color=always} -i -s -C 1 '\${BZB_GREP_QUERY}' {}"
fi
readonly no_grep_ignore_status

# Quick-launch Command: Used to open targets in their native client
init launch ''
has xdg-open && init launch 'xdg-open'
has open && init launch 'open'

# Prefer -I option to -i for removing files, if available
rm -I '' 2>&1 | grep '\(unrecognized\|invalid\) option' &>/dev/null && \
  init rm_interactive 'rm -ri' || rm_interactive='rm -rI'


# BINDINGS

# Set readline keybinds for cancelling prompts with ctr-g or double-escape
# Binding single-escape could cause side effects due to its use as a common meta character
bind '"\C-g":"\C-k\C-u
"' '"\e\e":"\C-g"' &>/dev/null

# Set fzf keybinds for movement and exit actions
init fzf_bind '--bind=alt-k:up,alt-j:down,ctrl-g:ignore,esc:cancel'
init fzf_submenu_bind '--bind=alt-k:up,alt-j:down,ctrl-g:unix-line-discard+print-query,esc:unix-line-discard+print-query'

declare -A key_definitions key_actions action_keys
map() {
  keys[${#keys[@]}]="$2"
  key_definitions["$2"]="$3"
  key_actions["$2"]="$1"
  action_keys["$1"]="$2"
}

map 'enter'                   'right'       "enter directory or edit file"
map 'enter2'                  'alt-l'       "enter directory or edit file"
map 'back'                    'left'        "go to parent directory (not moving past base directory)"
map 'back2'                   'alt-h'       "go to parent directory (not moving past base directory)"
map 'launch'                  'alt-q'       "quick-launch targets using native client"
map 'grep'                    'alt-/'       "grep for pattern specified at prompt ('left' will exit grep mode)"
map 'toggle-grep'             'ctrl-g'      "toggle grep mode preserving pattern / cancel submenu or prompt"
map 'move'                    'alt-m'       "move targets to directory named at prompt"
map 'rename'                  'alt-r'       "rename targets in current directory"
map 'move-rename'             'ctrl-alt-m'  "move/rename targets into directory named at prompt"
map 'move-rename2'            'ctrl-alt-r'  "move/rename targets into directory named at prompt"
map 'delete'                  'alt-x'       "delete targets"
map 'copy'                    'alt-c'       "copy targets to directory named at prompt"
map 'copy-rename'             'ctrl-alt-c'  "copy/rename targets into directory named at prompt"
map 'create-edit-file'        'alt-e'       "create/edit file named at prompt"
map 'create-file'             'alt-f'       "create file without editing"
map 'create-dir'              'alt-d'       "create directory named at prompt"
map 'create-enter-dir'        'ctrl-alt-d'  "create/enter directory named at prompt"
map 'bookmark-targets'        'alt-b'       "bookmark target directories"
map 'bookmark-current-dir'    'ctrl-alt-b'  "bookmark current directory"
map 'unbookmark-dirs'         'alt-u'       "unbookmark selected directories"
map 'unbookmark-current-dir'  'ctrl-alt-u'  "unbookmark current directory"
map 'next-bookmark'           'alt-right'   "go to next bookmarked directory"
map 'next-bookmark2'          'ctrl-alt-l'  "go to next bookmarked directory"
map 'prev-bookmark'           'alt-left'    "go to previous bookmarked directory"
map 'prev-bookmark2'          'ctrl-alt-h'  "go to previous bookmarked directory"
map 'select-bookmark'         'alt-up'      "select and enter bookmarked directory"
map 'select-bookmark2'        'ctrl-alt-k'  "select and enter bookmarked directory"
map 'select-nested-bookmark'  'alt-down'    "select and enter bookmarked directory under current directory"
map 'select-nested-bookmark2' 'ctrl-alt-j'  "select and enter bookmarked directory under current directory"
map 'set-alt-dir'             'alt-s'       "set alternate directory (default for copy/move prompts)"
map 'enter-alt-dir'           'alt-a'       "switch between current and alternate directory"
map 'enter-base-dir'          'alt-z'       "switch between current and base directory"
map 'enter-prev-dir'          'alt-p'       "switch between current and previous directory"
map 'prompt-dir'              'alt-g'       "go to directory named at prompt"
map 'set-base-dir'            'ctrl-alt-g'  "set new base directory at prompt and go to it"
map 'toggle-preview'          'ctrl-alt-p'  "toggle visibility of preview pane"
map 'toggle-status'           'ctrl-alt-t'  "toggle visibility of toggle status bar"
map 'toggle-ignored'          'alt-i'       "toggle visibility of ignored files (if supported)"
map 'toggle-hide'             'alt-v'       "toggle visibility of hidden files"
map 'toggle-nested'           'alt-n'       "toggle listing nested vs. only top-level files"
map 'toggle-sort-order'       'alt-o'       "toggle sort order ascending/descending"
map 'toggle-sort'             'ctrl-alt-s'  "toggle sorted/unsorted results (affects performance)"
map 'toggle-nested-sort'      'ctrl-alt-n'  "toggle sort order ascending/descending"
map 'restore-initial-view'    'ctrl-alt-i'  "restore initial view settings (don't show nested/hidden/ignored)"
map 'load-session'            'alt-y'       "load session from file named at prompt"
map 'save-session'            'ctrl-alt-y'  "save session to file named at prompt"

# comma-separated list of custom mappings for fzf
fzf_keys="$(printf ",%s" "${keys[@]}" | cut -c2-)"


# USAGE

usage() {
cat <<USAGE
usage: $script_name [options] [target file or directory]

Browse files using fzf. If no target is specified start in the current directory.

Key mappings:

$(awk -F ':' '{ printf("%-12s %-66s %s\n", $1, $2, $3) }' <(
cat <<KEY_USAGE
KEYMAP:DESCRIPTION:ACTION_NAME
escape:exit file browser
ctrl-c:exit file browser
enter:enter directory or edit file
$(for k in "${keys[@]}"; do echo "$k:${key_definitions[$k]}:${key_actions[$k]}"; done)
KEY_USAGE
))

Options:

--help                             Show this help text
--once,-o                          Exit browser after editing a file
--color,-c                         Show colorized output
--recursive,-r                     List nested files/directories at start
--no-hide,-H                          Show hidden files/directories at start
--no-ignore,-I                     Show ignored files/directories at start
--reverse-sort,-rs                 Reverse the normal sort order
--no-sort,-S                       Disable sorting of files/directories
--no-nested-sort,-NS               Disable sorting of nested files/directories
--no-edit,-E                       Log selections to file instead of launching editor
--no-preview,-P                    Disable preview pane that shows file/directory contents
--no-toggle-status,-T              Disable status header that shows current toggle settings
--autosave-session,-as             Save bookmarks and view/sort settings continuously
--autoload-session,-al             Load bookmarks and view/sort settings on entering base directory
--grep=PATTERN,-g=PATTERN          Start in grep mode, searching files for specified pattern
--base-directory=DIR,-bd=DIR       Specify base directory instead of deriving it from target argument
--alternate-directory=DIR,-ad=DIR  Initialize alternate directory at start

Most options can be inverted by reversing uppercase/lowercase for the short form or adding/removing
the 'no-' prefix for the long form. Additional options will be passed on to fzf, with the form using
an equals sign '=' required for options that take values. (e.g. '--query=STR' not '-q STR')
USAGE
}

for arg in "$@"; do
  case $arg in
    --help) usage; exit 0 ;;
    -o|--once) disable persist; shift ;;
    -O|--no-once) enable persist; shift ;;
    -c|--color) enable color; shift ;;
    -C|--no-color) disable color; shift ;;
    -r|--recursive) disable shallow; shift ;;
    -R|--no-recursive) enable shallow; shift ;;
    -h|--hide) enable hide; shift ;;
    -H|--no-hide) disable hide; shift ;;
    -i|--ignore) disable no_ignore; shift ;;
    -I|--no-ignore) enable no_ignore; shift ;;
    -s|--sort) enable sorted; shift ;;
    -S|--no-sort) disable sorted; shift ;;
    -ns|--nested-sort) enable nested_sort; shift ;;
    -NS|--no-nested-sort) disable nested_sort; shift ;;
    -rs|--reverse-sort) enable reverse; shift ;;
    -RS|--no-reverse-sort) disable reverse; shift ;;
    -e|--edit) disable no_edit; enable persist; shift ;;
    -E|--no-edit) enable no_edit; disable persist; shift ;;
    -p|--preview) enable preview; shift ;;
    -P|--no-preview) disable preview; shift ;;
    -t|--toggle-status) enable toggle_status; shift ;;
    -T|--no-toggle-status) disable toggle_status; shift ;;
    -as|--autosave-session) enable autosave_session; shift ;;
    -AS|--no-autosave-session) disable autosave_session; shift ;;
    -al|--autoload-session) enable autoload_session; shift ;;
    -AL|--no-autoload-session) disable autoload_session; shift ;;
    -g=*|--grep=*) enable grep_mode; grep_query="${arg#*=}"; shift ;;
    -bd=*|--base-dir=*|--base_directory=*) base_dir="${arg#*=}"; shift ;;
    -ad=*|--alt-dir=*|--alternate-directory=*) alt_dir="${arg#*=}"; shift ;;
    # Save remaining options for fzf with quoting preserved
    # TODO: Capture options set with values after whitespace, not just '=' style assignments
    -*) [[ "$arg" == *=* ]] && fzf_extra_options+=" ${arg%%=*}=\"${arg#*=}\"" || fzf_extra_options+=" \"$arg\""; shift ;;
  esac
done


# FILE STATE

save_selection() {
  if [[ $no_edit && -d $data_dir ]]; then
    selection="$data_dir/selection"
    mkdir -p "$(dirname $selection)" && touch "$selection"
    if [[ -w "$selection" ]]; then
      > "$selection"
      for t in "$@"; do
        if [[ -r "$t" ]]; then
          echo "$PWD/$t" >> "$selection"
        fi
      done
    fi
  fi
}

save_session() {
  if [[ -n "$1" ]]; then
    mkdir -p "$(dirname $1)" && touch "$1"
    if [[ -w "$1" ]]; then
      session="$1"
      readarray -t bookmarks < <(dirs -p -l)
      # Write session data to file
      declare -p PWD > "$session"
      [[ "$base_dir" ]] && declare -p base_dir >> "$session"
      [[ "$alt_dir" ]] && declare -p alt_dir >> "$session"
      declare -p bookmarks >> "$session"
      declare -p shallow >> "$session"
      declare -p hide >> "$session"
      declare -p no_ignore >> "$session"
      declare -p sorted >> "$session"
      declare -p reverse >> "$session"
      declare -p preview >> "$session"
    else
      echo "Error: Could not save session to '$1'" 2>&1
      read -s -r -n 1 -p "(Press any key to continue)"
    fi
  fi
}

restore_session() {
  dirs -c
  pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
  for b in "${bookmarks[@]}"; do
    [[ -d "$b" ]] && pushd "$b" >/dev/null
  done
  cd "$base_dir"
}


# MAIN

initial_target="$1"

# Derive base directory from target, or use current directory if none given
if [[ -z "$base_dir" ]]; then
  [[ -d "$initial_target" ]] && base_dir="$initial_target" || base_dir="$(dirname "${initial_target:-$PWD/.}")"
fi
pushd "$base_dir" >/dev/null && pushd +1 >/dev/null

# Optionally autoload browsing session
init session "${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
[[ $autoload_session && -r "$session" ]] && . -- "$session" && restore_session "$session"


main() {
  # Export variables for use in subshells
  export BZB_QUERY="$query"
  export BZB_COLOR="$color"
  [[ $hide ]] && export BZB_HIDDEN=1 || export BZB_HIDDEN=''
  export BZB_NO_IGNORE="$no_ignore"
  export BZB_REVERSE="$reverse"
  export BZB_GREP_QUERY="$grep_query"

  # Edit file or enter directory
  if [[ $# -eq 1 && -d "$1" ]]; then
    cd "$1"
    # clear query after changing directory
    export BZB_QUERY=''
  elif [[ $# -ge 1 ]]; then
    edit="${EDITOR:vi}"
    for f in "$@"; do
      edit="$edit '$f'"
    done
    [[ $no_edit ]] && save_selection $@ || bash -c "$edit"
    [[ ! $persist ]] && exit 0
  fi

  # Setup list/sort/preview commands
  [[ $shallow ]] && sort="$sort_shallow" || sort="$sort_recursive"
  [[ $shallow || $nested_sort ]] && sort_pipe="${sorted:+ | $sort}" || sort_pipe=''
  if [[ $grep_mode ]]; then
    [[ $shallow ]] && grep="$grep_shallow" || grep="$grep_recursive"
    preview_opts="--preview='$grep_mode_preview' --preview-window='right:62%:wrap'"
    fzf_input=$(bash -c "echo \"$grep$sort_pipe\"")
    fzf_prompt="/$grep_query/"
    [[ $no_grep_ignore_status ]] && ignore_disabled='!' || ignore_disabled=''
  else
    [[ $shallow ]] && find="$find_shallow" || find="$find_recursive"
    preview_opts="--preview='$find_mode_preview' --preview-window='right:62%:wrap'"
    fzf_input=$(bash -c "echo \"$find$sort_pipe\"")
    fzf_prompt="${PWD#$base_dir}>"
    [[ $no_find_ignore_status ]] && ignore_disabled='!' || ignore_disabled=''
  fi
  [[ ! $preview ]] && preview_opts=''

  # Prepare display to show status of toggle-settings
  status=()
  [[ $hide ]] && status+=('+hide') || status+=('-hide')
  [[ $no_ignore ]] && status+=("${ignore_disabled:--}ignore") || status+=("${ignore_disabled:-+}ignore")
  [[ $shallow ]] && status+=('-nested') || status+=('+nested')
  [[ $nested_sort ]] && nested_sort_enabled="/" || nested_sort_enabled='' 
  [[ ! $sorted ]] && sort_disabled='-' || sort_disabled=''
  [[ $sorted ]] && sort_enabled='+' || sort_enabled=''
  [[ ! $shallow && $sort_enabled && $parallel_sort ]] && sort_enabled="="
  [[ ! $shallow && ! $nested_sort_enabled ]] && sort_disabled='!' && sort_enabled='!'
  [[ $sorted && $sort_enabled ]] && status+=("${sort_enabled}sort${nested_sort_enabled}") || status+=("${sort_disabled}sort${nested_sort_enabled}")
  [[ ! $sorted || $sort_disabled ]] && reverse_disabled='!' || reverse_disabled=''
  [[ $reverse ]] && status+=("${reverse_disabled:-+}reverse") || status+=("${reverse_disabled:--}reverse")

  export BZB_FZF_HEADER="[${status[@]}]"

  # Clear leading dots from paths
  fzf_input+=" | sed 's:^\./::'"

  fzf_options="${no_clear:+--no-clear} --print-query --multi --layout='reverse' $fzf_bind --expect='$fzf_keys' --query='$BZB_QUERY' --prompt='$fzf_prompt' $preview_opts $fzf_extra_options"
  [[ ! $color ]] && fzf_options="${color:---no-color} $fzf_options"
  [[ $toggle_status ]] && fzf_options="--header=\"\$BZB_FZF_HEADER\" $fzf_options"

  # CYCLE INTO FZF
  fzf_command="$fzf_input | fzf $fzf_options"
  { read query; read command; readarray -t targets; } < <(bash -c "$fzf_command")

  # Parse empty command and empty target as 'exit' (fzf-native 'escape' or 'ctrl-c' mapping)
  [[ -z "$command" && "${#targets[@]}" -eq 0 ]] && exit 0

  # Parse empty command as 'enter' action
  [[ -z "$command" ]] && command='right'

  set action "${key_actions[$command]}"

  next_targets=()

  case $action in
    # Exit grep-mode if any other directory navigation is used
    next-bookmark|next-bookmark2|prev-bookmark|prev-bookmark2|select-bookmark|select-bookmark2|select-nested-bookmark|select-nested-bookmark2|enter-base-dir|prompt-dir|set-base-dir|enter-alt-dir|enter-prev-dir)
      disable grep_mode
    ;;

  # Fall through to remaining cases
  esac; case $action in

    # Use left arrow or alt-k to move up a directory, but not above base directory
    # If in grep mode, exit and resume browsing current directory
    back|back2)
      if [[ ! $grep_mode && "$PWD" != "$base_dir" ]]; then
        next_targets=("..")
      else
        next_targets=('.')
        disable grep_mode
      fi
    ;;

    # Use enter or right arrow or alt-j to edit file or enter directory
    enter|enter2)
      next_targets=("${targets[@]}")
    ;;

    # Use alt-/ to enter grep mode using search pattern specified at prompt
    # Use again to update search pattern. Enter empty pattern to cancel
    grep)
      clear && read -ep "Grep for Pattern: " -i "$grep_query" grep_query
      toggle grep_mode
    ;;

    # Use ctrl-g to toggle in/out of grep mode (not changing search pattern)
    toggle-grep)
      toggle grep_mode
    ;;

    # Use alt-n to toggle listing nested vs only top-level files/directories
    toggle-nested)
      toggle shallow
    ;;

    # Use alt-i to toggle visibility of ignored files/directories
    toggle-ignored)
      toggle no_ignore
    ;;

    # Use alt-v to toggle visibility of hidden files/directories
    toggle-hide)
      toggle hide
    ;;

    # Use alt-o to toggle between normal and reverse sort order
    toggle-sort-order)
      toggle reverse
    ;;

    # Use ctrl-alt-s to enable/disable sorting
    toggle-sort)
      toggle sorted
    ;;

    # Use ctrl-alt-n to enable/disable nested sorting
    toggle-nested-sort)
      toggle nested_sort
    ;;

    # Use ctrl-alt-p to toggle visibility of preview pane
    toggle-preview)
      toggle preview
    ;;

    # Use ctrl-alt-t to toggle visibility of toggle status bar
    toggle-status)
      toggle toggle_status
    ;;

    # Use ctrl-alt-i to restore initial view/sort settings
    restore-initial-view)
      enable shallow sorted preview toggle_status hide
      disable reverse no_ignore
      [[ $parallel_sort ]] && enable nested_sort || disable nested_sort
    ;;

    # Use alt-q to quick-launch targets in their native client
    launch)
      if [[ "$launch" ]]; then
        for t in "${targets[@]}"; do
          bash -c "$launch '$t'"
        done
      fi
    ;;

    # Use alt-r to rename targets in current directory
    rename)
      for t in "${targets[@]}"; do
        if [[ -r "$t" ]]; then
          clear && read -ep 'Move/Rename File: ' -i "mv \"$t\" \"$t\"" cmd
          [[ -n "$cmd" ]] && bash -c "$cmd"
        fi
      done
    ;;

    # Use alt-m to move targets
    move)
      clear && read -ep 'Move to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && mv -i "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-r or ctrl-alt-m to move and rename targets
    move-rename|move-rename2)
      clear && read -ep 'Move/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            read -ep 'Move/Rename File: ' -i "mv '$PWD/$t' '${dir%/}/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-x to delete targets
    delete)
      CMD="$rm_interactive"
      for t in "${targets[@]}"; do
        CMD="$CMD '$t'"
      done
      clear && bash -c "$CMD"
    ;;

    # Use alt-c to copy targets
    copy)
      clear && read -ep 'Copy to Directory: ' -i "${alt_dir:-$base_dir}" dir
      [[ -n "$dir" ]] && cp -ir "${targets[@]}" "$dir"
    ;;

    # Use ctrl-alt-c to copy and rename targets
    copy-rename)
      clear && read -ep 'Copy/Rename to Directory: ' -i "${alt_dir:-$base_dir}" dir
      if [[ -n "$dir" ]]; then
        for t in "${targets[@]}"; do
          if [[ -r "$t" ]]; then
            clear && read -ep 'Copy/Rename File: ' -i "cp -ir '$PWD/$t' '$dir/$t'" cmd
            [[ -n "$cmd" ]] && bash -c "$cmd"
          fi
        done
      fi
    ;;

    # Use alt-d to create directory named at prompt
    # Use ctrl-alt-d to create directory and enter it
    create-dir|create-enter-dir)
      [[ "$action" = "create-enter-dir" ]] && create_enter="Create/Enter" || create_enter="Create"
      clear && read -p "$create_enter directory: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$target"
        [[ "$command" = "${action_keys[create-enter-dir]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-f to create file named at prompt
    # Use alt-e to create file and edit it immediately
    create-file|create-edit-file)
      [[ "$action" = "create-edit-file" ]] && create_edit="Create/Edit" || create_edit="Create"
      clear && read -p "$create_edit file: " target
      if [[ -n "$target" ]]; then
        mkdir -p "$(dirname "$target")" && touch "$target"
        [[ "$command" = "${action_keys[create-edit-file]}" ]] && next_targets=("$target")
      fi
    ;;

    # Use alt-b to bookmark selected targets
    bookmark-targets)
      dir="$PWD"
      for b in "${targets[@]}"; do
        if [[ -d "$dir/$b" ]]; then
          cd "$dir/$b"
          [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
        fi
      done
      cd "$dir"
    ;;

    # Use alt-u to select bookmarks to delete
    unbookmark-dirs)
      current_dir="$PWD"
      readarray -t dirs < <(dirs -p -l)
      bookmarks=("$(printf '%s\n' "${dirs[@]}" | LC_ALL=C sort -u | fzf $fzf_submenu_bind --multi --prompt='[unbookmark]')")
      for b in ${bookmarks[@]}; do
        for i in "${!dirs[@]}"; do
          if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$b" ]]; then
            popd -n +$i >/dev/null
          fi
        done
      done
      cd "$current_dir"
    ;;

    # Use ctrl-alt-b to bookmark current directory
    bookmark-current-dir)
      [[ ! "$(dirs -l)" =~ " $PWD" ]] && pushd "$PWD" >/dev/null
    ;;

    # Use ctrl-alt-u to unbookmark current directory
    unbookmark-current-dir)
      for i in "${!dirs[@]}"; do
        if [[ $i -ge 1 && -d "${dirs[$i]}" && "${dirs[$i]}" = "$PWD" ]]; then
          popd +$i >/dev/null
        fi
      done
      pushd +1 >/dev/null 
    ;;

    # Use alt-right or ctrl-alt-l to go to next bookmarked directory
    next-bookmark|next-bookmark2)
      cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l +1)" && pushd -n +1 >/dev/null
      fi
    ;;

    # Use alt-left or ctrl-alt-h to go to previous bookmarked directory
    prev-bookmark|prev-bookmark2)
      cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      if [[ "$PWD" = "$OLDPWD" ]]; then
        cd "$(dirs -l -0)" && pushd -n -0 >/dev/null
      fi
    ;;

    # Use alt-up or ctrl-alt-k to select bookmarked directory using fzf
    select-bookmark|select-bookmark2)
      readarray -t dirs < <(dirs -p -l | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf $fzf_submenu_bind --prompt='[go to directory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-down or ctrl-alt-j to select bookmarked directory under current directory
    select-nested-bookmark|select-nested-bookmark2)
      readarray -t dirs < <(dirs -p -l | grep "$PWD" | LC_ALL=C sort -u)
      next_targets=("$(printf '%s\n' "${dirs[@]}" | fzf $fzf_submenu_bind --prompt='[go to subdirectory]')")
      [[ ! $next_targets ]] && next_targets=("$PWD")
    ;;

    # Use alt-p to go to previous directory
    enter-prev-dir)
      cd "$OLDPWD"
    ;;

    # Use alt-a to go to alternate directory, or go back
    # to previous directory if already in alternate directory
    # Use alt-s to set alternate directory
    set-alt-dir|enter-alt-dir)
      if [[ "$action" = "set-alt-dir" || ! -d "$alt_dir" ]]; then
        clear && read -ep "Set alternate directory: " -i "$PWD" dir
        [[ -d "$dir" ]] && alt_dir="${dir%/}" || echo "Not a directory"
      fi
      if [[ "$action" = "enter-alt-dir" && -d "$alt_dir" ]]; then
        [[ "$PWD" = "$alt_dir" ]] && cd "$OLDPWD" || cd "$alt_dir"
      fi
    ;;

    # Use alt-g to go to directory named at prompt
    prompt-dir)
      clear && read -ep "Go to directory: " -i "$PWD" dir
      [[ -d "$dir" ]] && cd "$dir" || echo "Not a directory"
    ;;

    # Use ctrl-alt-g to set/enter new base directory
    # Use alt-z to go to base directory, or go back
    # to previous directory if already in base directory
    set-base-dir|enter-base-dir)
      dir="$PWD"
      if [[ "$action" = "set-base-dir" || ! -d "$base_dir" ]]; then
        clear && read -ep "Set base directory: " -i "$dir" dir
        if [[ -d "$dir" ]]; then
          base_dir="${dir%/}"
          pushd "$base_dir" >/dev/null && pushd +1 >/dev/null
          session="${data_dir:+$data_dir/sessions$base_dir/session.bzb}"
          set action "autoload-session"
        fi
      fi
      if [[ ! -d "$base_dir" || ! -d "$dir" ]]; then
        echo "Error: Cannot set base directory to invalid path" 2>&1
        read -s -r -n 1 -p "(Press any key to continue)"
      elif [[ "$action" = "enter-base-dir" && "$PWD" = "$base_dir" ]]; then
        cd "$OLDPWD"
      else
        cd "$base_dir"
      fi
    ;;

  # Fall through to remaining cases
  esac; case $action in

    # Use alt-y to load session. May be triggered automatically by other actions,
    # in which case prompt will still appear if autoload_session setting is disabled
    load-session|autoload-session)
      restore="$session"
      if [[ "$action" = 'load-session' || ! $autoload_session ]]; then
        clear && read -ep "Load session: " -i "$restore" restore
      fi
      if [[ -r "$restore" ]]; then
        session="$restore"
        . -- "$session"
        restore_session
      fi
    ;;

    # Use ctrl-alt-y to save session
    save-session)
      clear && read -ep "Save session: " -i "$session" save
      save_session "$save"
    ;;
  esac

  # Optionally autosave browsing session
  [[ "$autosave_session" ]] && save_session "$session"

  main "${next_targets[@]}"
}

# Default initial target is current directory
main "${initial_target:-$base_dir}"
